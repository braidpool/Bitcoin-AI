I'm doing this a little differently. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and <u>.NET</u>. Any other language is not supported by a huge company or anything like this. So let's dive in. So I'm going to go through this. What is <u>.NET</u>? The architecture, design principles of the <u>.NET</u> architecture, the framework. Trying to exercise Microsoft from it so you guys take it easy on me. Then I will talk about myself, show a few projects done in <u>.NET</u> in the wild, and then answer the biggest question of it all: why am I using <u>.NET</u> to re-implement Lightning? And then what is my purpose doing this? So, <u>.NET</u> is a free and open source framework. It runs on Windows, Linux, and macOS. According to Microsoft, it's just a new platform based on internet standards. So this is pretty important. In July 2000, <u>.NET</u> Framework and <u>C#</u> language were introduced into the world at the PDC, the Professional Developers Conference. And then it was very <u>welcome</u> by the community because we need that. Before that, we had Visual Basic, and it was very difficult to work on Internet-first applications. So, back in 2000, in Brazil at least, Internet was just six years old. And then you need something built from Internet. They realized that this was the next big thing. And then in December 2001, just a little more than a year and a half after the launch, they published a standard, ECMA standard, 335 and ECMA 334. 335 is for the <u>Common Intermediate Language</u>. And 334 is for the <u>C#</u> language. So it's an open standard. Anyone could just implement the intermediate language part, like the runtime of <u>.NET</u> in any other architecture, <u>operating system</u>. So they created this, expecting people to contribute as well. And then right now we have just the sixth edition of ECMA and ISO standards. I will talk more about this later. And the last version is 2012 for the intermediate language stuff. So now I'll talk about architecture because people don't realize how powerful <u>.NET</u> is and how well it runs on every single architecture we have out there, every single <u>operating system</u>. So we have basically like the two big parts on it, and then there are smaller parts inside. We have three languages right now running on <u>.NET</u>. We have <u>C#</u>, we have Visual Basic for legacy stuff, because before <u>C#</u> there was only Visual Basic. And then here it's a number of things that make it work. So the first part is the CLI that goes here inside. This is the common language infrastructure. So this is a language neutral platform, and you can write code in <u>C#</u>. Nowadays we have F# as well, is a functional code language that works on <u>.NET</u> framework. So you can write <u>C#</u>, F#, or <u>VB</u> for legacy stuff, and it will run on the same interpreter, the same runtime. <u>J#</u>, as I said, was a transitional language. And then we have the CLR, the common language runtime. So what happens is you write code in <u>C#</u> or F#, the most user today, and then you compile this language. The compiler will translate whatever you wrote in <u>C#</u> or F#, so object-oriented or functional programming. It will translate it to the OS and architecture you chose. So the CLR is the execution engine. It also takes care of like giving away memory, taking care of memory garbage collection, threads. It takes care of it all. And then the memory management, the type safety, exceptions, garbage collector, security, thread management. It's responsible for it all. Uh we have the <u>CIL</u>, the <u>Common Intermediate Language</u> that I spoke about. Uh it's just this thing that the runtime, the interpreter understands, and it's very different from <u>C#</u> or F#. It's like assembly. You can read that. It's human-readable, sorts of, but it's not assembly yet. And then we have the just-in-time compiler. That's the part that takes the <u>Common Intermediate Language</u> and translates it to assembly. Then we have the assemblies that are part of the framework. When you compile your program in <u>C#</u>, it creates this portable executable. So, this is not assembly code yet. You cannot just run this on Linux or Windows. This is just this middle format. And then it takes a unique name for that package, for that program. It's comprised of the simple text name, just the name of our package, the version number, the culture, like the language it's written on, and the public key. You can sign the package, but usually we just use the public key that comes with it. If we're not trying to prove the code or anything, then it takes this, and you have the unique name, the <u>unique identifier</u> of the package. I will show you a little later, but then using this, it knows if it has to compile the code again to machine code or if it has on like a cache. And then we have the class library, which is the built-in API for the framework. So you have a couple namespaces. The two most common ones are system.something and Microsoft.something. So those are built-in libraries that you can call to talk like to the OS, to make system calls, function calls to third-party libraries, and then you can talk directly to the <u>operating system</u>. The good things about <u>.NET</u>, like the design principles they had in mind before doing this, is the interoperability. So, Windows, who here knows about Windows programming? No one, nice. Yes, just one. So, Windows is like the mainstream first window like UI <u>operating system</u> we have. And then they needed something to allow the developers to talk directly to the OS. So they created something called COM, the <u>Component Object Model</u>. So you can write <u>COM models</u> in any language, and then this layer in Windows lets another application use this. A good example of a <u>COM model</u> is ActiveX or DirectX that we use to talk directly to the GPU on games. So this was very important since the beginning, since Windows 3.11. Windows 95 made a very heavy usage of this and it's still used in Windows applications. And then to talk to this, you have the interop service and the enterprise services. Enterprise services, you talk directly to Windows, Windows Server, and other Windows applications. And interop services, you can talk directly to the Linux or macOS <u>operating system</u> and make system calls. You can call default libraries from the system. We have the <u>reverse PInvoke</u>, the platform invoke, to call systems or function calls from the <u>operating system</u>. So you can build base stuff on <u>.NET</u> and have other applications in Linux use it as a library. So in <u>NLightning</u>, I'm using <u>libsodium</u>. So this is a good example. I call <u>libsodium</u> to do the cryptographic stuff, and then it's just a simple call you do. And I could rewrite <u>libsodium</u> in <u>.NET</u> or something better, do something better with my time than trying to rewrite <u>libsodium</u>. And then other people could write <u>C</u> code or <u>C++</u> code and call those functions as well from <u>.NET</u>. And language independence is a good principle as well because now we can have <u>C#</u>, F#, and if someone here wants to write a language that runs on top of the standard, the ECMA or ISO standard, you can write your own language as well, your own compiler, and it will run on the <u>.NET</u> framework. Type safety. So <u>.NET</u> is like talking more about the language because when we talk <u>.NET</u> is usually you think about <u>C#</u> because the language was introduced at the same time as the framework. So it likes the same thing. So in <u>C#</u> we have CTS and CLR the common part of the framework enforcing type safety, so it's a strongly typed language. Everything has to be typed, or else it doesn't work. And then a couple years ago, up to <u>.NET Framework 4.0</u>, it was strictly typed language. And then after <u>Framework 4.0</u>, they introduced a dynamic language model. They changed it CLR. So <u>C#</u> was the first language that adopted it, of course. So, now we have dynamic objects as well. So, this is good if you're trying to use like some JavaScript APIs, because then they don't care about versions or breaking changes, and you're not sure what you're getting from the API. You can just read that object into a dynamic type, and then you can just call like the object.data and then it tries to find data in that structure. And if there's data, it returns else it's just a null, so you know data is not present there. And this is good for the new kinds of system people are writing nowadays. So it's nice to have a dynamic language, but it's obtained. If you don't want to use dynamics anymore, just go with the <u>strictly typed</u>. Portability, this is good as well. Microsoft implemented the full framework for Windows only. So I will show you a timeline in the next slide. But at some point, it was just <u>.NET</u>, <u>C#</u> and <u>VB.NET</u>, and <u>J#</u> just for Windows. It was implemented by Microsoft for Microsoft developers and for Microsoft users. So <u>.NET</u> ships in Windows because most of the Windows applications are written in <u>.NET</u>. And then with this open standard, the ECMA standard and the ISO standards, anyone could write the runtime to a specific OS or architecture. And since it's open, people would be able to run the same code like you write once, the <u>C#</u> code, and it would run on any architecture. It took a while for people to start doing this, but it's portable, it's a portable language. And security, this is a good topic because I will show you later as well, but almost every single bank in the world uses <u>.NET</u>. Almost every single insurance company in the world uses <u>.NET</u>. Almost every single airliner uses <u>.NET</u> on the internal processes. Like Icarus is written <u>.NET</u>. And then it has to be secure. So they have the security, and I will talk a little about the security, why they choose this language. So we have its own security mechanism to access memory and take care of the execution of programs. So we have the CAS, the code access security, and the validation and verification of whatever you're trying to run. An example is a method that demands a specific permission from the <u>operating system</u>. So it will, on execution time, it will walk through all the libraries you're trying to execute. It will walk through this, and then it will find if every single namespace, every single assembly there has that authorization, right? The permission to execute that code. If one of those are missing, it throws an exception, a security exception, and the code will not execute. So you can create very robust secure applications. One little caveat of the security is you have, like I said, you have an intermediate language that is human-readable. So <u>.NET</u> was launched on Visual Studio, and on Visual Studio, you have a disassembler. And since it's an intermediate language, very readable, you can very easily get a portable executable, like the compiled stuff, and you can get back almost the original source code from this library or an application. And you can see every single method, the tabulation, everything. It almost rewrites it completely. So companies were like, well, this is not good because if I have some proprietary code and I'm publishing it, anyone can read my code, anyone can copy me. So from the second version of Visual Studio with <u>.NET</u>, it ships with <u>Microsoft Obfuscator</u>. And then there's a plethora of obfuscators out there. We have VMware obfuscators, we have JetBrains obfuscators, like a lot. We have more than 25 commercials available and free ones like the Microsoft one that ships with Visual Studio. So you can obfuscate your code as well. So memory management. Like I said, <u>.NET</u> is a managed framework. So you don't take care of memory. The framework takes care of memory for you. So, a lot of you work in <u>C</u>, <u>C++</u>, Rust, Go. In Rust, like you have to instantiate the object, you call for memory, you use that point of memory, and then you use the pointer here and there, and then you are responsible for clearing that pointer or lending that pointer to another function and all of that. In <u>C</u>, <u>C++</u>, you have to really take care of everything. There's no landing, there's no anything. The compiler doesn't know what's happening. So you are responsible. In <u>.NET</u> Framework, you don't care. You just new object, and it takes memory from the pool of memory from the runner that is taking care of your application. And then whenever you're not using that pointer anymore, the garbage collector goes there and just frees the memory and compacts the memory, and that's it. So CLR handles all of this memory operations. The instantiations are allocated from the manage pool. And then, as long as there is a reference, it's considered being used. And then, as long as there is no reference on the tree, the memory tree, it can be freed. It's considered garbage. And the garbage collector, which is a big selling point of <u>.NET</u> over Java, it runs periodically, but we don't know when it runs. So it's a non-deterministic garbage collector. It depends on how much memory your application is using and the memory pressure from the <u>operating system</u>. If the system starts telling the runtime, like I need memory, then it runs the garbage collector, but we don't know when. And then it's a mark and sweep garbage collector. And I will tell you a little more about this. So it pauses the app, your application is paused whenever the garbage collector needs to run. But it runs in a way that is very performant. So it pauses the application, goes through the three routes we have, like system objects, static objects, and user objects. And then it walks through the tree and then finds through disassembly sometimes objects inside of objects and all the pointers they have. If something is in memory and it's not on this tree, it marks as garbage. When it finishes this walkthrough, it just marks that memory as free, and then it compacts the memory, the memory pool. So it moves around all the objects in the memory to have a contiguous memory, right? So it's easier, it's faster when you want to instantiate a new object. It goes to the end of the pool, so it's very fast to give you memory. But then the question is, this runs whenever it wants. I don't know when. And it pauses my application and goes through the whole tree and compacts the memory. This is slow. And actually, no, because it uses a generational stuff. So the first time it runs, it runs through the tree. And then it marks objects that have pointers still being used. It marks as gen 1 and what's not being used, it's freed. And then the next run, it will not go through generation 1 because it's supposed to be long-lived. So it just runs through like newly created objects. After this, it will run a couple more times, and then whoever survives generation one, then it's a long-lived object. So it goes to generation two. And generation two garbage collecting happens less often. So it's not running through your whole memory, your object tree, every time. It just goes through generation zero a lot, generation one a little, and generation two almost never. Performance. So the <u>CIL</u> code compilation is performed on the first run. So, whenever you build a new program, you change it, something, you're going to run it. Remember, you have this intermediate language. It's not built for, it's not compiled to your architecture and <u>operating system</u>. So, the first run will compile the code to machine code, and then this compiled machine code executable goes to a cache, <u>.NET</u> cache. And then, whenever you try to run this another time, it gets that unique ID, like the version, the name, the culture, public key. If it has on the cache, it just runs whatever it has from the cache. So the first run is slower, like not considerably slower. I'm used to having startup times on the first time, like two or three seconds. Second time is just milliseconds because it just goes to the cache and runs the application. We have ahead of time compilation for this specific purpose because if I have an application that I uh like a core application of my system and this has to run the first time very fast because I don't have time. Like it's a Lambda or something written <u>.NET</u>, it has to run fast on the first call. So you can do ahead of time compilation because you know the architecture, you know the <u>operating system</u>. You just manually compile that to assembly code, to machine code, and then you ship that assembly code. And then on the first run, it's already on cache, right? You don't have to compile to that architecture anymore. It's already there. As I said, like the GC can introduce unanticipated lag delays on the execution, but you can try to bypass it and you can try to run the GC manually as well. On <u>NLightning</u>, I have a lot of unmanaged code. And whenever you're doing unmanaged code, you're responsible for the memory from that point on. So we have some calls that you can tell GC that you have memory pressure and that GC should run faster than it would otherwise. And you can remove pressure, like I'm not using that much memory, I'm not about to run a big process. Let the GC run less often. And then you have a way of forcing GC collect. I've done this before. We had like on a bank, we were processing those consolidation files. So it's just clear text, hundreds of megabytes, almost one gigabyte file, like all the transactions from the day between two banks, and they are trying to consolidate all of that shit. Then I would call GC collect before doing that processing, because I forced the GC to the garbage collector to go through generation zero, one and two and absolutely clean the memory. So I have more memory to work with on the pool, more contiguous memory, which is more important. So now the Microsoft apostasy. Let's exorcise the Microsoft demon out of <u>.NET</u>. How it went, the open sourcing of <u>.NET</u>. And this is a part where everyone gets it wrong. When I say that I'm doing <u>.NET</u> implementation of Lightning, people just go bananas. Like, what are you doing? Why <u>.NET</u>? Are you crazy? And even further, we already have four implementations. Why a fifth one? And in a language that is not open source. So here it is. July 2000, <u>C#</u> introduction. And then January 2001, <u>DotGNU</u>. It's a free open source Linux implementation of the ECMA standards. So they re-implemented from scratch the intermediate language compiler to architecture specific and the runtime that deals with threads, memory, and whatever else. So following the standard, the specification, they were implementing <u>DotGNU</u>. Unfortunately, went through some pushback from the open source community because back in 2001, it was very new. They were afraid of moving, getting too close to the beehive and getting sued by Microsoft. Because it was like no one knows what Microsoft will do. It's an open standard, but what if I try to do stuff that is not the CLI or the <u>C#</u> language? What if I'm doing something that is proprietary work from Microsoft? They can sue us. So this project doesn't went far. But then in July 2001, Mono was another free open source implementation for Linux. This launched it at O'Reilly conference. The guy behind it, I will talk a little more about him. The guy behind it started working in like July 2000, but then he realized it was an Herculean task to rebuild everything from scratch for Linux. And I'm talking like Windows stuff from the framework because they were trying to port <u>.NET</u> applications to run natively on Linux without using Wine or anything like this. So he was rewriting every single bit. And then he decided it was not an easy task, so I will call for help. So it was open sourced in July 2001. Then July 2004, just three years after going open source, <u>Mono 1.0</u> was released, the first major version. I use that a lot because I started doing <u>.NET</u> stuff in 2001. So I use that a lot to port my applications to Linux, to run on Linux. But it was a mess, right? It was a guy not from Microsoft trying to implement stuff from scratch. In 2012, we got a setback from the community. I remember some Reddit drama back then because someone at Microsoft, like a VP, tried to grab control of the repository, try to change how commits were made, how <u>merges</u> were accepted, and how the release were made on <u>.NET</u>. And then we have a pushback from the community. They ended up letting people go or moving to another area apart from <u>.NET</u> Framework. And then they changed the licensing terms and the patent for <u>.NET</u> Framework to be anyone does whatever they want. We cannot sue you, even if you infringe on patents, because now it's just a holding patent. It's not a patent anymore. You can do whatever you want. You can use Microsoft code whatever you want, and you can just create your own implementation. So, this was a piloting point where Microsoft just stepped away from the <u>.NET</u>-like governance, and now it's ours. Then November 2014, just two years after that, <u>.NET</u> Core was introduced. So we have <u>.NET</u> Framework, it's proprietary, it's Windows only, and we have <u>.NET</u> Core. Now it runs on Linux, macOS, and Windows natively. And all the APIs, the lower-level APIs were written by Microsoft employees. And now the full source was open sourced. So now it's our code for real this time. And then here is where it's a little sad because Mono and the Mono developer were not invited to come along. Mono was a thing, and <u>.NET</u> Core was another. And then they were like clashing against each other because people were using Mono with a lot of bugs, and you know, it was harsh. And then there's Microsoft doing what the guy was doing, and then everyone just moved it to <u>.NET</u> Core. Then <u>.NET</u> Core 1.0, 2016, 2017, the second version, 19, the last version. We have 18, 2.4, 2.6, 2.7, and then 3.0 in July 2019, December we have 3.1. This was the last <u>.NET</u> Core implementation. After this, they skipped <u>.NET</u> 4. So <u>.NET</u> Framework was on the version 4, and they didn't want people to have one or the other erroneously because both were <u>4.0</u>. So they skip it. 2020, we have <u>.NET</u> 5. They got rid of the proprietary stuff from the framework. They ported 100% of the APIs to the open source code. And now the open source code contains Windows original code for us to use. So 2020, another big landmark for us. We have stable releases every November. The even numbers are long-term support, three years. The odd numbers are one and a half year support. Right now, November last year, we have <u>.NET</u> 9, which is not long-term support. So I'm sticking to <u>.NET</u> 8. And this year I will move my application to <u>.NET</u> 10. <u>C#</u> launches a new major as well alongside <u>.NET</u> new versions. So <u>C#</u>, we are on <u>C# 12</u>. <u>.NET 9</u> is <u>C# 13</u>, and this year we will have <u>.NET 10</u>, <u>C# 14</u>. They have a minimization of <u>breaking changes</u> mindset, so it works for at least nine years, whatever you have. So we have code, like not crazy code, like vanilla code written in <u>C#</u>, that <u>C#</u> for <u>.NET 1.0</u>, <u>2.0</u> framework that still runs on Linux on <u>.NET</u> 9 because there's not that much <u>breaking changes</u>. So you can run legacy applications to this day. So Mono. Let's talk about Mono. It was created by <u>Miguel de Icaza</u>. A lot of people know this guy because he created GNOME. And he is the founder of <u>Ximian</u> and <u>Xamarin</u>. For people that delved into Android iOS apps in <u>.NET</u>, we had <u>Xamarin</u> because he wrote the framework from scratch for iOS and Android. So you wrote <u>.NET</u> applications running on Android and iOS. He did it from scratch for Linux desktop apps at first. He open sourced it in July, as I said. The parent <u>Ximian</u> was acquired by Novell in 2003 and then he was acquired with the company. He worked on this company. It was still like <u>Ximian</u>, but it was Novell. He sold every single patent and license that he has to Novell. It was part of the deal. And then we had a problem in Novell because they just went bankrupt. So they started letting go of a lot of people, including <u>Miguel de Icaza</u>. And then it was a hard time for us using this, using Mono for Linux because we don't know what's happening because the license is Novell's licenses. And then Miguel launches <u>Xamarin</u> and then there's this gray area. What we will do? Can we keep working on what we were working? Is it the same work we were doing at Novell? We cannot do this anymore. Novell just stopped supporting the Mono framework. And then in 2011, Novell granted a perpetual licensing to <u>Xamarin</u> over Mono, MonoTouch, and Mono Android. MonoTouch was for iOS. And then we got back to having <u>.NET</u> applications safely on Android and iOS. The v4 incorporated in 2012, v4 incorporated original Microsoft code that was open sourced after that pushback from the community in 2012, because then Microsoft let everyone use their code. So they just grab a lot of code from Microsoft, and now Mono runs very smooth. And as of June 2024, we have v6.12. It has the core API of <u>.NET</u> framework, so it's a full framework working on Linux for desktop applications mainly. We have <u>VB.NET</u> and <u>C# 7</u>, so he cannot keep up with what Microsoft is doing, right? The open source community turns to the core implementation and now just <u>.NET</u>. So he doesn't have that much contributors. So we are still in <u>C# 7</u>, but on the <u>.NET</u> framework, we are using <u>C# 13</u> now. So he's far back, and there is a lot of good stuff happening from <u>C# 9</u> onwards. It's insane what you can do. You can just make sure your code is being inlined by the compiler. You can make sure that you stay in processor cache most of the times in some applications that I did before. So it's very powerful to use Microsoft stuff. But he's still working hard on this. And he has most of the APIs. He has full support for <u>LINQ to Objects</u>. It's writing lambdas for collections, like for database, and translating this to database, whatever database you're using. You just write this in <u>C#</u> and translates to the database commands and also for collections. XML, SQL, Windows Forms, WPF for people from the Microsoft world, this gives us chills, but people are still using it. And they can import applications to Linux, thanks to Miguel. So now I'm getting to the beginning of the presentation because now I gave you guys a context of <u>.NET</u>. You know a lot about <u>.NET</u> now. It's open source. There is no Microsoft involved. Even in the governance, they just have grants for developers, and they have like developers from their payroll just folks that are <u>.NET</u>. But now about myself. So I started reading and writing at four. I started, I learned <u>COBOL</u> and <u>dBase II</u> at five. My mom was a programmer, so she was teaching me how to do <u>COBOL</u> stuff on an 8086 what is Toshiba T twelve hundred so it's like a big laptop like five six kilos twenty five minutes of battery life one twenty megabyte hard drive and one three point five inches disk drive so this was and running DOS <u>3.6</u> this was my first computer. We got this computer when I was four. And then at five, I was the only one in the house doing stuff for everyone because I knew how to manage it. Then I delved into a lot of programming languages throughout my career. I'm 40, by the way, so this is a long time ago. 35 years ago, I started doing this. So I went to <u>C</u>, <u>C++</u>, Pascal, Basic, Visual Basic, <u>Delphi</u>, <u>Perl</u>, Ruby, Python, JS, TS, ActionScripts for Flash. This was the goal back then for websites. Then a lot of stuff in Bash, Java, <u>C#</u>, SQL, you name it. I've been through it all. I've been doing this for 15 years as a professional. And I've been through like 40-something companies in 15 years. So I move a lot, I learn fast. When they cannot offer me anything else, I move to another company, try to find a challenge. So I went through a lot of things, a lot of different systems through my career. I have experience in embedded systems because back then in the 90s, you're not just doing computers, you're doing like <u>PIC</u>, you're doing 8-bit microprocessors. It was beginning to get cheap, so you write <u>C</u> and compile to machine code for those. So I did a lot of professional stuff as well. In São Paulo, we have the ATM machines to top up your transit cards. I did that from São Paulo as a whole, Hugo Nero, Portalegri. It's used on more than 160 cities. And I did from the scratch, from hardware, firmware, software, and everything, recording on the card, and <u>NXP card, MIFARE stuff</u>. I'm a professional programmer for the past 15 years. I have experience in mission-critical applications. Most of my experience is in mission-critical. So, the transport system in Brazil, like in Sao Paulo. If I do something wrong and I push code to production, there's like hundreds of thousands of angry people at 5 p.m. trying to catch a bus or the subway trying to get home. So I'm very experiencing initial critical stuff. I work at banks in Brazil, COPOF banks, credit card processors, acquires, subacquires, transportation cards, like I said. And I've been working with Bitcoin for the past eight years as a professional. So I left the regular financial system and I went to Bitcoin only. So I worked in a lot of exchanges in Brazil. I did something here and there for exchanges overseas. And then 2024, last year, about June, July, I got my grant from <u>OpenSats</u> to do what I will show you right now. So before this, free open source software using <u>.NET</u>, there's a bunch. I put some here. If you run a media server at home, you are using <u>.NET</u> without knowing. <u>BTCPay Server</u> is all written <u>.NET</u>. The creator of <u>BTCPay Server</u> is <u>Nicolas Dorier</u>. And he created <u>NBitcoin</u>, which is like a cousin of <u>NLightning</u>, and with both Nicholas. But the N is for <u>.NET</u>, right? So he wrote everything, including <u>SECP</u> in <u>.NET</u> managed code. And we have <u>NBitcoin</u> to do everything. I use <u>NBitcoin</u> a lot to talk to Bitcoin, Bitcoin Core, and to do like transaction signatures. I use his code. Then we have <u>Radarr, Sonarr, Lidarr, Prowlarr</u>. It's used to find torrents and to download music, TV shows, and movies over Tor network, please. And we have <u>Jellyfin</u> as well, which is a media server that you can just use your TV to stream that. So we have a streamer written in <u>.NET</u> as well. And then we have like Umbraco CMS, which is one of the biggest CMS providers, and it's written in <u>.NET</u>, it's open source. <u>nopCommerce</u>, Orchard Core, there's a big list. I put some of the biggest ones. And I skipped this: who uses <u>.NET</u> in the wild? We have Citigroup, Citibank, JP Morgan Chase, Wells Fargo, Bank of America, HSBC, Standard Charter, ING, AIG, <u>Allianz, AXA</u>, MetLife, Prudential, <u>Stack Overflow</u>.NET. So we rely on <u>.NET</u> every day. Every single one of you uses <u>.NET</u> every single day. Dell, GoDaddy, <u>Accenture</u>, Siemens, UPS, and we have everyone that is a gamer uses <u>.NET</u> because Unity is a game engine that is written in <u>.NET</u>. So why <u>.NET</u>? I guess it's clear by now, right? I want to break the barrier for the big fish. We are not capable of changing the global ecosystem as we as developers. We are not that much doing Bitcoin development and we don't have the <u>buying power</u> to just make something huge that will make Bitcoin mainstream. Those guys, they have. They use <u>.NET</u>. Which CTO from Citibank in her in his their righteous mind will hire a Rust developer in a bank that there's just like thousands of <u>.NET</u> developers to run Bitcoin in-house, to run Lightning in-house? It's not happening anytime soon. They will not run <u>C</u> and <u>C++</u> because people writing <u>C</u> and <u>C++</u> are expected to be like older than me. So it's not happening. They are not doing it. They do <u>.NET</u>. So I'm trying to break this barrier, offering them a <u>.NET</u> system that they already know. They pay millions of dollars every month. Those companies together pay billions of dollars to Microsoft for support, like top-tier support. I work on the Ministry of Education in Sao Paulo, and we had a memory leak back when <u>.NET</u> was beginning to get open source, and then we were calculating the retirement for the year for all the teachers in Brazil. So you can imagine retired teachers clicking the button non-stop and then we have to run these calculations whenever they click there and then it's <u>.NET</u> and we had a memory leak. We discovered this running a big simulation two years prior to the date. It cannot fail. So we tried to find the memory leak. We were unable to find the memory leak. We called Microsoft. They put an engineer on a car with us. He accessed the production computer, like the pre-production computer where we were running the simulation. Without seeing the source code, he was able to get the intermediate language and debug this remotely. And then he find out, like debugging the framework code as well, because he has the code in his machine. He can debug that. He found that the memory leak was something on the framework. On the next day, we had a patch, a public patch, fixing that. They installed it for us, and then the next day, it went smoothly. So, this is the kind of support I'm talking about. You cannot get this from the Rust community, you cannot get this from the Go community, you cannot get this from the Python community. It's inexistent. There's no people that will offer this because if they offer this, people will pay top dollar. That's why we have <u>Red Hat</u>, that's why we have OpenSUSE. It's open source, they build it, they sell support. So that's huge. Like OpenSUSE, it's a billion-dollar contract with <u>three-letter agencies</u> on the United States. The defense uses it. Like everyone uses it. FBI, NSA, they pay for support because if something goes wrong on the <u>operating system</u>, they solve it now. And Microsoft offers this. So they're already paying this. It's easy. If I do something wrong, or any of you that want to contribute to the project, if we do something slightly wrong and we cannot fix it, those guys are going to call Microsoft and they will fix it for us. So this is very important for huge companies. I'm breaking a big barrier here. What else? Well, ease of integration with existing services, because it's going to be easy for them to integrate their app that is calling <u>.NET</u> with a Lightning implementation. It's easy for them. It has a huge performance. <u>.NET</u> is you can do crazy stuff. I wrote alongside three other engineers, I wrote a book, an order book for an exchange in Brazil. We were able in six months to write another book that was processing 1.6 million transactions per second using <u>.NET</u>. We were debugging stuff and then we realized it the circular array we were using was running on L2 cache, the processor. We wrote a lot of unmanaged code to do this, and it was <u>.NET</u>. At <u>Zebedee</u>, I was writing some stuff there before I leave, and we got to 2.6 million transactions per second using <u>.NET</u>. Like end-to-end, from the user clicking to saving on the database. 2.6 million transactions per second. So it's very performant. We cannot take that out of the table. It's easily scalable because <u>.NET</u> is multi-thread. So you can scale horizontally, you can scale vertically, you can have like intelligent balancing tools. If the pressure is too much, the next machine that goes up can be very big and it just ingests whatever traffic you have. Then you can go down to smaller machines, put things out. So it's very scalable. It's secure. Everyone is using it, their support. So all the banks are using it. It's very secure. And it's portable. So they can just decide to move from, I don't know, Linux servers to Windows servers again. I don't know why they would do that, but they can do that. And you don't have to change a single line of code. It just runs. You can just test code like myself on a MacBook. It just runs. It's the same experience. I lost my train of thought. Well. Oh, yeah, yeah. So it's very portable because now you can you don't have to change a single line of code. It just works on every single architecture out there, including embedded systems. So, right now we have <u>.NET</u> portable being maintained. You can write <u>.NET</u> code and run on a microprocessor. So it's very reliable. So, what is Lightning Endgame? Why am I doing this? So, by the end of year, I will have a full implementation of the Lightning network. Right now, I'm missing two <u>BOLTs</u>. I have the communication layer, the transport layer ready. I have all the messages ready. And it's modular, right? Because I came from an enterprise system. So I'm doing enterprise level code here. So it's very modular. You can just install the <u>BOLT</u> package and then using enlightening.<u>BOLTs</u>.<u>BOLT 2</u> messages. And then you can write whatever you want, and you have the messages there. I just want to import the transport layer because I'm doing like phishing stuff here and there and trying to do an interceptor or something. You can do that. You just import <u>BOLT 8</u>, it's a transport layer. And then on top of the base implementation of the spec, I'm doing services that has all the logic for those specifications. So instead of going implementing everything by hand, like I have the transport layer, I have the messages. How do I connect to other lightning nodes? No, I have a service. So you just instantiate the service and.connect, and you pass the endpoint. And then it will do the <u>Noise protocol</u> stuff, it will talk to the other peer, it will go to a peers list, and then you can choose a peer and just send messages. You have a message service, you have the transport service. So it's very scalable and modular. So you can do whatever you want to <u>NLightning</u> in code. It's already at 70%. It's unit tested a lot. I have 75% coverage, branch coverage on this. So it's good to go. It's production ready, I would say. And the good thing is, <u>Zebedee</u> already uses it in production. So I launched the package <u>BOLT 11</u>, and Richard next day calls me, hey, thank you for that. It's in production at <u>Zebedee</u>. So doing the interceptor stuff, because he was like doing some <u>Rust LDK</u> calls, and it's a mess to do those calls in <u>.NET</u> because the names of the functions and the objects, and to catch an error, it's insanely huge because of the bindings. So now he has a way of doing this on managed code that he speaks. So <u>Zebedee</u> is using this for six months now. No complaints from Richard, no open ticket yet. I want to implement by the end of the year this <u>drop-in daemon replacement</u> for all the implementations we have out there. So I'm planning to do, I'm expecting help by the middle of the year. I'm expecting help, more hands to code with me. Then by the end of the year, we will have this replacement, <u>drop-in replacements</u>, meaning I will import your configurations, your private keys, and your database, and now it runs on <u>NLightning</u>. You can choose on <u>NLightning</u> right now. You are able to choose from four different databases. So you can use Microsoft SQL, Postgres, MySQL, and Oracle databases. And it's ready. You just create the migrations and it works on all four databases. And you're welcome to write more implementations to other obscure databases if you want. In the near future, I want to offer enterprise-level paid support for those companies from the previous slide. So, I want to create a company on top of this, just like OpenSUSE did and <u>Red Hat</u> did. So, I wrote this. I can give you the best support in the world because I know how it works. So, I can train people, and we can offer support to those big guns. And then, we are breaking that entry barrier for banks, and we might have Lightning and Bitcoin for the masses. So that's it. Thank you. This is enlightening.ipms.io. This is the documentation portal. And this is the email reaches at IPMS. We have a couple minutes. I want to show you guys what's happening. Can I see it there? Oh, thank you. So we have the documentation portals because in <u>.NET</u> you can write inline XML comments on your functions and everything. And then you just can create on every release, I have this beautiful specification API, and then you can just go through this and see how to call, how to instantiate the messages, the audio objects, what uses it. And it's like document as you code. So, this is very powerful as well for the open source community. Well, I guess that's it. Questions? We have like one minute. If you have any questions about it? No? Okay, thank you.