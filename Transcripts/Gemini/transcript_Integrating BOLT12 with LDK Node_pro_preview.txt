Hi, I'm Elias. I'm <u>@_tinal</u> on Twitter or online anywhere. I'm an engineer with Spiral working on the Lightning <u>Dev Kit</u>. And this talk will be a bit more technical than the talks I heard in this stage before today. Although I think there are a lot of connections that can be drawn from the other talks to this. Yeah, as the title states, this is on <u>BOLT 12</u>: what it is, why we want it, and how to integrate it with <u>LDK Node</u>.
Alright, where are we today? So, today we have <u>BOLT 11</u> invoices. Everybody is familiar with them, they're ubiquitous, used everywhere you use Lightning today. And they're the original payment protocol, essentially invoices. They're great, they are tried and true, and they worked so far pretty well for the most part. But everybody is kind of aware of the flaws that <u>BOLT 11</u> invoices have. In particular, they have this interactivity requirement, basically. So, if you want to pay a friend, you always have to ask them first: "Hey, can you send me an invoice?" Because they're not reusable. And this is kind of annoying to always ask somebody, "Hey, please send me an invoice, I want to send you some money."
And even more so, of course, they're kind of large. If you can see this here, it's probably hard to read. But the data that goes into a <u>BOLT 11</u> invoice, the encoding is rather large, which is fine if you just send it as a text message or whatever. But if you want to encode them in a QR code, which is the usual way we do Lightning transactions these days, it's kind of annoying that they are so large because you might want to add additional data into that same QR code. And the more data you put into a QR code, I'm not sure if you're aware of that, the harder it gets to scan. It gets more dense and that means that older smartphones for example have an issue scanning them if the camera isn't that great.
But even worse than these issues, which are mainly <u>UX</u> issues, <u>BOLT 11</u> has poor privacy generally because it leaks the payee <u>pubkey</u>. You always, if you send an invoice to somebody, you say, "Hey, this is my node." You leak your identity, basically. So we don't have what's called recipient anonymity in the <u>BOLT 11</u> world. Of course, there are some ways to mitigate some of it. You can always run on Tor or whatever, but in general, this is not the greatest thing to have. We want to have recipient anonymity.
<u>LNURL</u> Lightning Addresses mitigate some of the UX issues just discussed. So they allow you to retrieve individual invoices from a web server. So instead of asking your friend every time, "Hey, can you give me a new invoice?", you ask a web server, "Hey, can I get a new invoice?" And this improves the <u>UX</u>. The issue with that is it requires running a web server, which is kind of annoying because that is another tech stack you have to work with. It introduces additional complexity. And on top of that, there are additional privacy and security risks that just come with running or with that increased attack surface essentially of running a web server. So it improved things considerably, but it's still not quite where we really want to be.
Of course, that's where <u>BOLT 12</u> comes in, <u>BOLT 12</u> to the rescue. Granted, it has been a long time coming, so it's a really slow jog to the rescue, essentially. I think I just looked it up these days. In just a few days, I think August 31st will be like the four-year anniversary that Rusty opened the spec PR for offers for <u>BOLT 12</u> on the Lightning spec repo. So it has been some time that protocol devs have been working on this and discussing this and so on. But the good thing is, the good news is it's here. It's actually working and it fixes basically all the aforementioned drawbacks of <u>BOLT 11</u>. We have reusable, smaller offers. They can be static. You can generate them, you can put them on a website or whatever. They don't change. And then people can send you money.
Even more so, it guarantees receiver or recipient anonymity. You don't leak your <u>pubkey</u> anymore, and you have no additional dependencies to your tech stack with all the drawbacks we just discussed because it's now an actual base <u>spec</u> of the Lightning protocol and is already implemented in your Lightning Node, hopefully.
So, to focus on the privacy aspect real quick, and here it gets a bit technical, but I don't want to get into too much detail. How does <u>BOLT 12</u> ensure the privacy part? How do we get around leaking the <u>pubkey</u>? Well, <u>BOLT 12</u> uses something that's called blinded paths. So, this whole thing is a depiction of a blinded path. And you can see here is this opaque thing that is, you cannot look into it basically, this whole box. So, instead of the recipient node actually putting its <u>pubkey</u> in there, the only thing that the sender sees is the introduction point. And everything in here is encrypted, actually multiple times via <u>onion encryption</u>, meaning that the only thing that's leaked is an introduction node that is chosen by the recipient itself. And so now when that is included in the offer here, and that is the offer that is just sent via QR code, like out-of-band, like we do currently with <u>BOLT 11</u> invoices to Alice, the sender. And you see, there's a blinded path in there. So, what Alice now does, if she wants to pay this offer, is to send an invoice request using that blinded path to Bob via the introduction node, of course, not to Bob directly. And then Bob responds with a <u>BOLT 12</u> invoice. Yes, on the protocol level there is something like a <u>BOLT 12</u> invoice, but you likely will never see it when using it because it's really a protocol detail, it's really a message on the protocol level. The only thing you should really deal with is offers and what we call refunds, which are basically invoice requests if you want to refund somebody. Anyways, there are <u>BOLT 12</u> invoices that will be sent back via a similar reply path construction basically. So, Bob also still doesn't know who Alice is. And then, finally, we can send the actual payment.
So, you see, it's a kind of involved protocol, lots of cryptography going on, and all of this is communicated over <u>onion messages</u> on the protocol level. And these <u>onion messages</u> are then routed. Here is another depiction. Basically, here you have your route in the network, and this would be your introduction point. And here's Bob. So hopefully, this will be routed in the network via <u>onion messages</u>. Slight caveat here: currently, as not everybody currently in the network is supporting <u>BOLT 12</u>, or rather, <u>onion message</u> forwarding, more often than not, we currently, when we use <u>BOLT 12</u>, we connect to the introduction point directly and send the <u>onion message</u> from there. But in the future, and I'll be coming back to that, we'll hopefully see full routed <u>onion messages</u>.
So, how does adoption look like? <u>BOLT 11</u>, I said, is ubiquitous. And where are we with <u>BOLT 12</u> currently? Well, Phoenix deployed it. You can use it today in the wallet. It works. <u>LDK</u>, we support it in <u>LDK</u>, <u>LDK Node</u>. It's ready to go. <u>CLN</u>, although, while they, I think, are currently catching up to the latest spec, but it's really just pending a release, they support it, of course. And <u>LND</u> is committed to add support in the near future. And in the meantime, you can run a project, <u>LNDK</u>, which is basically a neat little project, a separate daemon on top of <u>LND</u> that provides <u>onion message</u> forwarding and also <u>BOLT 12</u> send to you if you run an <u>LND</u> node. So I can just encourage you to do that.
Cool. So, apart from that, why do you start actually adopting it? Sounds a bit complicated to get started, especially if you're not super technical or if you're not too familiar with the Lightning protocol details. So, where do we start? The answer is a thing we call <u>LDK Node</u>. <u>LDK Node</u> is a Lightning Node library based on <u>LDK</u> and <u>BDK</u>, so it comes with an associated on-chain wallet ready out of the box. And the focus of <u>LDK Node</u> is really to provide a simplified experience to write self-custodial Lightning <u>nodes</u>. So it provides a library so you can write self-custodial Lightning <u>nodes</u>. And we think self-custody is important. Self-custody is important. I agree with the talk before that it's hard currently in many aspects. Self-custody in Lightning can be hard, but we are on the other hand working hard towards making it simpler for users and <u>LDK Node</u> hopefully helps you to do that so you can just include it and integrate it in your app and basically we take care of all these protocol details for you. It has a modular architecture, so it comes with customizable chain data, gossip data, entropy, and liquidity source <u>backends</u>. So we integrate with the LSP spec, for example, to also solve stuff like onboarding of initial users. We integrate <u>LSPS2</u>, which the <u>JIT channel spec</u> is called. So, where you would, for example, be able to create an invoice, and then when the invoice is paid, the LSP you connect to automatically opens a channel to you, hopefully, even a <u>Zero-Conf channel</u>, which makes onboarding really seamless. So, if you're aware of the Phoenix onboarding experience, where you don't have to care if you have an initial channel open or not, basically you get the same thing with this <u>just-in-time spec</u>.
And then we provide language <u>bindings</u> to you so that while it is written in Rust, <u>LDK Node</u>, you can write your programs in Kotlin, Swift, Python, Flutter, React Native, Go, C, in all these languages, and they should basically have the same simplified API ready to go so you can integrate self-custodial Lightning <u>Nodes</u>, for example, in your mobile application.
So, I want to run through a real quick example just to showcase that it's really straightforward to use it. Although I'm not expecting, I'm not entirely sure how the crowd here is, how technical people are, so I'll try to keep this short. Just to get set up with a node, essentially, you would create a builder object, and on this builder, you can configure all kinds of things. That is basically the modular architecture I just described. You can plug in your own explorer backend or whatever, configure, "I want to run this on testnet or mainnet or whatever, <u>regtest</u>." And then you call just builder.build() and you get a node object. And this is your Lightning Node. You're basically done. You just set up the Lightning Node. And you call start() on it, and then it starts up and it syncs with the explorer server, it updates fees and so on. So basically, in these five lines of code, you already set up a Lightning node. And yeah, that is more or less ready to go. You can then get a funding address, for example, to fund the node and then open a channel, which we see in the next step. Or, as I just mentioned, you can call one method to get a just-in-time invoice that is then payable. And if you connect to an LSP, you would also configure that on the builder. The LSP would open the channel to you.
Similar, as I just mentioned, you would also just, it's essentially one method call to open a channel to another node. You just say, "Okay, I want to connect to this <u>pubkey</u> at this address," and then you would open a channel and you get an event back when the channel is opened. And coming back to <u>BOLT 12</u>, this is basically the same goes for integrating <u>BOLT 12</u>. So we really tried to streamline the API here to make it really easy to integrate <u>BOLT 12</u> payments. Once you have an open channel, you have liquidity, either via the LSP or you did manually open the channel, you can just call node.<u>bolt12_payment</u>.send for any given offer, and there goes your <u>BOLT 12</u> payment. And that in the background does take care of all that complexity I mentioned in the beginning. Similarly, of course, you can also receive to <u>BOLT 12</u> by just creating an offer and then giving that out, and that would be your static offer that people can send payments to many times. And we also, as I mentioned before, support refunds, for example. That is essentially, you can think of them as invoice requests without an offer that kind of switches around the flow I showed before. Don't want to get into details too much here.
So, just to wrap this up, essentially, this example: this is a fully functional Rust program setting up a Lightning Node, starting the Lightning Node, getting a funding address where you then can fund, opening a channel, and sending a <u>BOLT 12</u> payment. So, in this, what is it? Maybe if you cut out the whitespace, it's actually 15 lines of code or something, you integrated <u>BOLT 12</u> payments. Cool. So, it's not that complicated to get started.
And the future that was the future for the last four years is now here. Now that the future is here, what's next? For one, human-readable names will be upcoming, which is the current <u>BIP</u> proposal by <u>Matt Corallo</u> and <u>t-bast</u> also. And there's the idea we can include these static offers now into the DNS (Domain Name System) as static entries, and we get something that is very similar to an email address format where you don't have to remember or you don't have to scan the QR code, you have actually a human-readable name for somebody. So, in many use cases, scanning a QR code makes more sense. But if you just want to ask a friend, "Hey, we just had dinner or whatever. I want to pay you back. What's your human-readable name?" That is much easier than sending around QR codes or offer encodings. That will be great.
Then people are also working on, actually, a colleague of mine is working on the async payment proposal, which will finally enable async receive. That has to do with an even more complicated protocol based on <u>onion messages</u>, a lot more messages to be exchanged and a lot more tricky details where which <u>onion message</u> will be held at which LSP site basically to enable async payments. But that is coming and is actively worked on.
And finally, coming back to the note of forwarding or routed <u>BOLT 12</u> payments, these will be coming in the future. As currently, around 6% of the forwarding nodes in the network have <u>onion message</u> forwarding enabled. <u>CLN</u> currently, it's an experimental feature, you have to enable it. So, I encourage you: if you run a <u>CLN</u> node, please enable <u>onion message</u> forwarding. And if you run <u>LND</u>, as mentioned before, please run <u>LNDK</u>. You get <u>BOLT 12</u> send for free and you also help the network to get this number higher so we can have eventually routed <u>BOLT 12</u> payments for the full network. I mentioned, as I said, direct connecting to the introduction point is fine for now, but eventually we want to reach fully routed payments in the network.
Cool. So far for that integration talk. Thanks so much for the attention. If you want to get further resources, please visit lightningdevkit.org. We have also a very active Discord community where we answer all your... where we try to give great user support. So ask anything there also. You can reach me via <u>@_tinal</u> on X, I guess, and/or <u>elias@spiral.xyz</u>. And or just ask now, please. Cool. Thank you.
[Q&A Section]
Hey. For the <u>BOLT 12</u> refund, I'm assuming where the refund being pushed from is the guy who's going to send the fees, right? Like, where do the fees come from? If it's going to be rerouted backwards, I'm guessing that they're not going to just... I'm guessing that they're not going to just give away the fees, right?
No, for the refund, it's actually, I mean, refund is a bit at the same time the right notion, but it's also confusing because it's not actually rerouting the actual payment, right? It's a new payment, we just call it refund because it inverts the direction. So, in the offer case, you basically scan an offer, you send an invoice request, basically say, "Hey, I want to give you money, please send me an invoice." And with a refund, you basically do it the other way around. The original recipient, if we keep it in the refund use case, would send back directly an invoice request saying, "Hey, here's an invoice request. If you send me an invoice, I can give you money," basically. That just switches, that leaves out the first offer request basically, or the invoice request part, yeah.
Could you give a bit more details on the <u>BIP 353</u> with the human readable name and the integration with DNS? How will it technically work with the integration on DNS?
Well, it's just a TXT record basically, where you add that to your domain you control. You would secure that via <u>DNSSEC</u>, so that nobody or that is basically signed. And then there are basically two different options how you could go. You could either do a wildcard thing that might make more sense for a big custodian that has thousands and thousands of users, where you can say basically pay to one specific offer and then give additional data to let the custodian know, "Okay, this is for this user." That is one, then you would have just one entry. Or you can have individual entries per user and have individual offers essentially per user. So every user would have an individual entry.
And the format of those entries, would they look like an email address or is it like alias.spiral.xyz? Is it free?
I think it could be free text. Yeah, I think the Bitcoin Design community discussed that a lot. How should we basically format these human-readable names? Because from a technical level, you can do, of course, everything. And as far as I'm aware, the last point of discussion ended up being that it should look like an email address, so you can easily copy and paste it, but it is prefixed with a Bitcoin sign, or you can either write the Bitcoin sign, or it should always in the UI be prefixed with a Bitcoin sign, so it is clearly distinguishable from an email address. Because if you use the email address format like Lightning Address, you can have conflicts with actual email addresses, and that is kind of annoying in some parts. Maybe in setups where you already have email addresses and you want to run Lightning Addresses on top, but they might not always match or something like that. So, yeah, to get around this, the idea is to have the address clearly distinguishable to show: "Okay, this is not an actual email address," let's say.
I don't know what, like <u>_tinal</u> or whatever. If you go to <u>12.cash</u>, I don't know if you can show it here quickly, but some of the designers have been experimenting with what that actually looks like in practice, and you can generate your own <u>BIP 353</u>-compliant name. So, yeah, check out <u>12.cash</u>.
I wanted to ask how reliable is the <u>BOLT 12</u> compared to <u>BOLT 11</u>? I can imagine if some nodes in the path get offline or if there are liquidity problems, then the invoice stops working. Or how does it work?
So, from the payment reliability, it's the same. It's just a bit more messaging complexity. So, the payment step is exactly the same as with <u>BOLT 11</u>. It's really just before you would just immediately send the payment after getting the invoice, and now you have basically this one and a half round trips or so in the beginning to negotiate until you get the invoice, essentially. So it's just a bit more complexity on negotiating, and there things can currently fail, but you can essentially just retry. Yeah. Okay, thank you.
So, but the point, maybe just to add to that, the good thing is that what makes Lightning payments sometimes fail is that mostly there's not enough liquidity on the path. And <u>onion messages</u> don't have this limit, so, or are not encumbered by any kind of liquidity, so they're not expected to be unreliable in the same sense as payments are. So, we're not getting a lot more unreliable with that. So, if there's basically, if you have a TCP connection with a node, you should be able to send. And if you don't have one, you can't send a payment over that link anyways. Okay, thanks.
The async payments in the future, what does that refer to? Because it's already async, meaning like you make the offer today, you get paid tomorrow.
Yeah. The async payment part is really that currently both parties have to be online at the same point in time to be actually to send and receive the payment. Because you send out the HTLC and then have to claim it back, and you have to be online for every part to actually be able to claim it again. And async payments is essentially a model, without getting into too many details here, where likely both sides would have an LSP. And you could think, so if you want to do it really trivially, you would have like, a real simple way to do that would be basically to have HODL payments, essentially, and you would just wait until the receiver comes back online. But that's horrible for network liquidity, to just block out liquidity. So the idea with async payments is both sides would have an LSP and you would hold the liquidity only on the sender side basically. So the liquidity is only locked between the sending node and their LSP. And then you would have an <u>onion message</u> protocol that would negotiate and basically notify the LSPs, "Hey, the receiver now came online, please forward this payment now. They're able to receive it." And actually, the other way around, also. So yeah. It's a bit more tricky to get everything right, but I think we're making good progress there. Thank you.
And just to clarify, this would really solve the major Lightning drawback of having to be online to receive payments. So finally, can solve that. Cool. Great, then thank you again.
