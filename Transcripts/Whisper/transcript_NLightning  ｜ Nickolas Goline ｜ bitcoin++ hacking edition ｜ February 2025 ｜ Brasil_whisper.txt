I'm doing this a little differently. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I'll give you guys a little introduction on why this is the biggest question. So you can see it here, like, about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I'm going to go through this. What is .NET? The architecture, design principles of the .NET architecture, the framework, trying to exercise Microsoft from it. guys take it easy on me. Then I will talk about myself, show a few projects done in .NET in the wild, and then answer the biggest question of it all. Why am I using .NET to reimplement Lightning? And then what is my purpose doing this? So .NET is a free and open-source framework. It runs on Windows, Linux, and Mac OS. According to Microsoft, it's just a new platform based on internet standards. So this is pretty important. In July 2000, .NET Framework and C-Sharp Language were introduced to the world at the PDC, the Professional Developers Conference. And then it was very welcomed by the community because we need that. Before that, we had Visual Basic. work on internet-first applications. So back in 2000, in Brazil at least, internet was just six years old. And then you need something built from internet. They realized that this was the next big thing. And then in December 2001, just a little more than a year and a half after the launch, they published a standard, ECMA standard, 335 and ECMA 335. 335 is for the language itself, for C-sharp. Sorry, 335 is for the common intermediate language, and 334 is for the C-sharp language. So it's an open standard. Anyone could just implement the intermediate language part, like the runtime of .NET other architecture, operational system. So they created this expecting people to contribute as well. And then right now we have just the sixth edition of ECMA and ISO standards. I will talk more about this later. And the last version is 2012 for the intermediate language stuff. So now I'll talk about architecture because people don't realize how powerful .NET is. and how well it runs on every single architecture we have out there, every single operational system. So we have basically like the two big parts on it. And then there are smaller parts inside. We have three languages right now running on .NET. We have C Sharp. We have Visual Basic for legacy stuff because before C Sharp, there was only Visual Basic. work. So the first part is the CLI that goes here inside. This is the common language infrastructure. So this is a language neutral platform. And you can write code in C sharp. Nowadays, we have F sharp as well as a functional code language that works on .NET framework. So you can write C sharp, F sharp, VB for legacy stuff and it will run on the same interpreter, the same runtime. Jsharp as I said was a transitional language and then we have the CLR, the common language runtime. So what happens is you write code in C sharp or F sharp, the most used today, and then you compile this language. The compiler will translate whatever you wrote in C sharp or F sharp. So object-oriented or functional programming. It will translate it to the OS and architecture you chose. So the CLR is the execution engine. It also takes care of giving away memory, taking care of memory, garbage collection, threads. It takes care of it all. And then the memory management, the type safety, exceptions, collector, security, thread management. It's responsible for it all. We have the CIL, the common intermediate language that I spoke about. It's just this thing that the runtime, the interpreter understands. And it's very different from C-sharp or F-sharp. It's like assembly. You can read that. It's human readable, sort of. But it's not assembly yet. have the just-in-time compiler. That's the part that takes the intermediate common language and translates it to assembly. Then we have the assemblies that are part of the framework. When you compile your program in C Sharp, it creates this portable executable. So this is not assembly code yet. You cannot just run this on Linux or Windows. This is just this middle format. And then it takes a unique name for that package, for that program. It's comprised of the simple text name, just the name of our package, the version number, the culture, like the language it's written on, and the public key. You can sign the package, but usually we just use the public key that comes with it. We're not trying to prove the code or anything. Then it takes this, and you have the unique name. identifier of the package. I will show you a little later, but then using this, it knows if it has to compile the code again to machine code or if it has on like a cache. And then we have the class library, which is the built-in API for the framework. So you have a couple of namespaces. The two most common ones are system.something and Microsoft.something. libraries that you can call to talk to the OS to make system calls, function calls to third-party libraries. And then you can talk directly to the operational system. The good things about .NET, like the design principles they had in mind before doing this is the interoperability. So Windows, who here knows about Windows programming? No one. Nice. Yes, just one. So Windows is like the mainstream first window UI operational system we have. And then they needed something to allow the developers to talk directly to the OS. So they created something called COM, the Component Object Model. You can write COM models in any language, and then this layer in Windows lets another application use this. A good example of a COM model is ActiveX or DirectX that we use to talk directly to the GPU on games. This was very important since the beginning, since Windows 3.11. Windows 95 made a very heavy usage of this. still use it in Windows applications. And then to talk to this, you have the interop service and the enterprise services. Enterprise services, you talk directly to Windows, Windows Server, and other Windows applications. And interop services, you can talk directly to the Linux or Mac OS operational system and make system calls. You can call default libraries from the system. And we have the reverse P invoke, the platform invoke to call systems or function calls from the operational system. So you can build like base stuff on .NET and have like other application in Linux use it as a library. So in Lightning, I'm using Libsodium. So this is a good example. I call Libsodium to do the cryptographic stuff. And then it's just a simple call you do. And I could rewrite libSodium in .NET or do something better with my time than trying to rewrite libSodium. And then other people could write C code or C++ code and call those functions as well from .NET. And the language independence is a good principle as well because now we can have C sharp, F sharp. of the standard, the ECMO or ISO standard, you can write your own language as well, your own compiler, and it will run on the .NET framework. Type safety. So .NET is talking more about the language because when we talk .NET, it's usually you think about C-sharp because the language was introduce it at the same time as the framework. So it likes the same thing. So in C Sharp, we have CTS and CLR, the common part of the framework, enforcing type safety. So it's a strongly typed language. Everything has to be typed or else it doesn't work. And then a couple years ago, up to framework, .NET framework 4.0, It was strictly typed language. And then after own 4.0, they introduced a dynamic language model. They changed CLR. So C Sharp was the first language that adopted it, of course. So now we have dynamic objects as well. So this is good if you're trying to use some JavaScript APIs, because then they don't care about versions or breaking changes and you're not sure what you're getting from the API, you can just read that object into a dynamic type and then you can just call the object dot data and then it tries to find data in that structure. And if there's data, it returns. Else is just a null, so you know data is not present there. And this is good for the new kinds of systems. People are writing nowadays, so it's nice to have a dynamic language. But it's opt-in. If you don't want to use dynamics anywhere, just go with the circulate type. Portability, this is good as well. Microsoft implemented the full framework for Windows only. So I will show you a timeline in the next slide. But at some point, it was just .NET, C Sharp, and VBnet and Jsharp just for Windows. It was implemented by Microsoft for Microsoft developers and for Microsoft users. So .NET ships in Windows because most of the Windows applications are written in .NET. And then with this open standard, the ECMA standard and the ISO standards, anyone could write the runtime to a specific OS or or architecture. And since it's open, people would be able to run the same code like you write once, the C-sharp code, and it would run on any architecture. It took a while for people to start doing this, but it's portable. It's a portable language. And security, this is a good topic because I will show you you later as well, but almost every single bank in the world uses .NET. Almost every single insurance company in the world uses .NET. Almost every single airliner uses .NET on the internal processes. Like Icarus is written .NET. And then it has to be secure. So they have the security and I will talk a little about the security, why they choose this language. We have its own security mechanism to access memory and take care of the execution of programs. So we have the CAS, the Code Access Security, and the validation and verification of whatever you're trying to run. An example is a method demands a specific permission from the operational system. So it will, on the execution time, out the libraries you're trying to execute. It will walk through this, and then it will find if every single namespace, every single assembly there has that authorization, the permission to execute that code. If one of those are missing, it throws an exception, a security exception, and the code will not execute. So you can create very robust, secure applications. One little caveat of the security is, like I said, you have an intermediate language that is human readable. So .NET was launched on Visual Studio, and on Visual Studio, you have a disassembler. And since it's an intermediate language, very readable, you can very easily get a portable executable, like the compiled stuff, And you can get back almost the original source code from this library or an application. And you can see every single method, the tabulation, everything. It almost rewrites it completely. So, companies were like, well, this is not good. Because if I have some proprietary code and I'm publishing it, anyone can read my code, anyone can copy me. Visual Studio with .NET. It ships with Microsoft Obfuscator. And then there's a plethora of obfuscators out there. We have VMware obfuscators. We have JetBrains obfuscators. Like a lot. We have more than 25 commercial available and free ones like the Microsoft one that ships with Visual Studio. So you can obfuscate your code as well. So memory management. Like I said, .NET is a managed framework. So you don't take care of memory. The framework takes care of memory for you. So a lot of you works in C, C++, Rust, Go. In Rust, you have to instantiate the object. You call for memory. You use that point of memory. And then you use the pointer here and there. responsible for clearing that pointer or landing that pointer to another function and all of that. In C, C++, you have to really take care of everything. There's no landing, there's no anything. The compiler doesn't know what's happening. So you are responsible. In .NET Framework, you don't care. You just new object and it takes memory from the pool of memory from the runner that is taking care of your application. in that pointer anymore, the garbage collector goes there and just free the memory and compacts the memory and that's it. So CLR handles all of this memory operations. The instantiations are allocated from the managed pool. And then as long as there is a reference, it's considered being used. And then as long as there is no reference on the tree, the memory tree, it can be free. It's considered garbage. And the garbage collector, which is a big selling point of .NET over Java, it runs periodically, but we don't know when it runs. So it's a non-deterministic garbage collector. It depends on how much memory your application is using and memory pressure from the operational system. If the system starts telling the runtime, like, I need memory, Then it runs the garbage collector, but we don't know when. And then it's a mark and sweep garbage collector. And I will tell you a little more about this. So it pauses the app. Your application is paused whenever the garbage collector needs to run. But it runs in a way that is very performant. So it pauses the application, goes through the three routes we have, like system objects, static objects, objects and then it walks through the tree and then finds through disassembly sometimes objects inside of objects and all the pointers they have. If something is in memory and it's not on this tree, it marks as garbage. When it finishes this walkthrough, it just marks that memory as free and then it compacts the memory, the memory pool. around all the objects in the memory to have a contiguous memory, right? So it's easier, it's faster when you want to instantiate a new object. It goes to the end of the pool, so it's very fast to give you memory. But then the question is, this runs whenever it wants. I don't know when, and it pauses my application and goes through the whole tree and compacts the memory. This is low. And actually, no, because it uses a generation of stuff. So the first time it runs, it runs through the tree and then it marks objects that has pointers still being used. It marks as Gen 1 and what's not being used, it's freed. And then the next run, it will not go through Generation 1 because it's supposed to be long-lived. So it just runs through like newly created objects. After this, it will run a couple more times And then whoever survives generation one, then it's a long-lived object. So it goes to generation two. And generation two, garbage collecting happens less often. So it's not running through your whole memory, your object tree every time. It just goes through generation zero a lot, generation one a little, and generation two almost never. Performance. So the CIL code compilation is performed on the first run. So whenever you build a new program, you change something, you're going to run it, remember you have this intermediate language. It's not compiled to your architecture and operational system. So the first run will compile the code to machine code, machine code executable goes to a cache, .NET cache. And then whenever you try to run this another time, it gets that unique ID, like the version, the name, the culture, pub key. If it has on the cache, it just runs whatever it has from the cache. So the first run is slower, like not considerably slower. I'm used to having startup times on the first time, or three seconds. Second time is just milliseconds because it just goes to the cache and runs the application. We have ahead of time compilation for this specific purpose because if I have an application that I like a core application of my system and this has to run the first time very fast because I don't have time. Like it's a lambda or something written dot net. It has to run fast on the first call. So you can do ahead of time compilation because you know the architecture, you know the operational system. You just manually compile that to assembly code, to machine code, and then you ship that assembly code. And then on the first run, it's already on cache, right? You don't have to compile to that architecture anymore. It's already there. As I said, the GC can introduce an anticipated lag, But you can try to bypass it and you can try to run the GC manually as well. In Lightning, I have a lot of unmanaged code. And whenever you're doing unmanaged code, you're responsible for the memory from that point on. So we have some calls that you can tell GC that you have memory pressure and the GC should run run faster than it would otherwise. And you can remove pressure. I'm not using that much memory. I'm not about to run a big process. Let the GC runs less often. And then you have a way of forcing GC collect. I've done this before. We had on a bank, we were processing those consolidation files. So it's just clear text. hundreds of megabytes, almost one gigabyte file, like all the transactions from the day between two banks, and they are trying to consolidate all of that shit, then I would call GC collect before doing that processing. Because I forced the GC, the garbage collector, to go through generation zero, one, and two, and absolutely clean the memory. So I have more memory to work with on the pool. More contiguous memory, which is more important. So now the Microsoft apostasy. Let's exercise the Microsoft demon out of .NET. How it went, the open sourcing of .NET. And this is a part where everyone gets it wrong. When I say that I'm doing .NET implementation of Lightning, people just go bananas. Like, what are you doing? Why .NET? Are you crazy? And even further, we already have four implementations. Why a fifth one? that is not open source. So here it is. July 2000, C Sharp introduction. And then January 2001, .gnu. It's a free open source Linux implementation of the ECMA standards. So they re-implemented from scratch the intermediate language compiler to architecture specific. that deals with threads, memory and whatever else. So following the standard, the specification, they were implementing it. .new unfortunately went through some pushback from the open source community because back in 2001 it was very new. They were afraid of moving, getting too close to the beehive and getting sued by Microsoft because it was like no one knows what Microsoft will do. It's an open standard. But what if I try to do stuff that is not the CLI or the C-sharp language? What if I'm doing something that is proprietary work from Microsoft? They can sue us. So this project doesn't went far. But then in July 2001, Mono was another free open source implementation for Linux. conference. The guy behind it, I will talk a little more about him, the guy behind it started working in like July 2000. But then he realized it was an Herculean task to rebuild everything from scratch for Linux. And I'm talking like Windows stuff from the framework because they were trying to port .NET applications to run natively on Linux without using Wine or anything like this. So he was rewriting single bit. And then he decided it was not an easy task, so I will call for help. So it was open sourced in July 2001. Then July 2004, just three years after going open source, model 1.0 was released, the first major version. I used that a lot because I started doing .NET stuff in 2001. So I used that a lot to port my applications to Linux, to run on Linux. It was a guy, not from Microsoft, trying to implement stuff from scratch. In 2012, we got a setback from the community. I remember some Reddit drama back then because someone at Microsoft, like a VP, tried to grab control of the repository, tried to change how commits were made, how merge were accepted, and how the release were made on .NET. And then we have a pushback from the community. They ended up like letting that people go or moving to another area apart from .NET Framework. And then they changed the licensing terms and the patent for .NET Framework to be anyone does whatever they want. We cannot sue you even if you infringe on patents because now it's just a holding patent. pattern anymore. You can do whatever you want. You can use Microsoft code, whatever you want. And you can just create your own implementation. So this was a pivoting point where Microsoft just stepped away from .NET governance. And now it's ours. Then November 2014, just two years after that, .NET Core was introduced. So we have .NET framework. It's Windows only. And we have .NET Core. Now it runs on Linux, MacOS, and Windows, natively. And all the APIs, the lower level APIs, were written by Microsoft employees. And now the full source was open sourced. So now it's our code for real this time. And then here is where it's a little sad because Mono and the Mono developer, invited to come along. Mono was a thing and .NET Core was another. And then they were like clashing against each other because people were using Mono with a lot of bugs and, you know, it was harsh. And then there's Microsoft doing what the guy was doing. And then everyone just moved it to .NET Core. Then .NET Core 1.0 2016. 2017, the second version. 2019, the last version. We have 2018, 2.4, 2.6, 2.7, and then 3.0 in July 2019. December, we have 3.1. This was the last .NET Core implementation. After this, they skipped .NET 4. So .NET Framework was on the version 4. And they didn't want people to have the one or the other erroneously because both were 0.4. So they skipped it. 2020, we have .NET 5. They got rid of the proprietary stuff from the framework. They ported 100% of the APIs to the open source code. And now the open source code contains Windows original code for us to use. So 2020, another big landmark for us. We have stable releases every November. The even numbers are long-term support, three years. The odd numbers are one and a half year support. Right now, November last year, we have .NET 9, which is not long-term support. So I'm seeking to .NET 8. And this year, I will move my application to .NET 10. C Sharp launches a new major as well alongside .NET new versions. So C Sharp, we are on C Sharp 12. C-sharp 13 and this year we'll have .NET 10, C-sharp 14. They have a minimization of breaking chains mindset, so it works for at least nine years, whatever you have. So we have code, like not crazy code, like vanilla code written in C-sharp, that C-sharp for .NET 1.0, 2.0 framework that still runs on Linux, on .NET and 9 because there's not that much breaking changes. So you can run legacy applications to this day. So Mono, let's talk about Mono. It was created by Miguel de Icaza. A lot of people know this guy because he created GNOME. And he is the founder of Xemian and Xamarin. For people that delve into Android iOS apps, we had Xamarin because he wrote the framework from scratch for iOS and Android. So you wrote .NET applications running on Android and iOS. He did it from scratch for Linux desktop apps at first. He open-searched it in July, as I said. The parent Xemion was acquired by Novell in 2003. And then he was acquired. with the company. He worked on this company. It was still like Xemian, but it was Novell. He sold every single patent and license that he has to Novell. It was part of the deal. And then we had a problem in Novell because they just went bankrupt. So they started letting go of a lot of people. including Miguel de Casa. And then it was a hard time for us using this, using Mono for Linux, because we don't know what's happening because the license is Novell's licenses. And then Miguel launches Xamarin. And then there's this gray area, what we will do. Can we keep working on what we were working? Is it the same work we were doing at Novell? do this anymore. Novell just stopped supporting the Mono framework. And then in 2011, Novell granted a perpetual licensing to Xamarin over Mono, Mono Touch, and Mono Android. Mono Touch was for iOS. And then we got back to having .NET applications safely on Android and iOS. V4 incorporated original Microsoft code that was open-sourced after that pushback from the community in 2012, because then Microsoft let everyone use their code. So they just grabbed a lot of code from Microsoft, and now Mono runs very smooth. And as of June 2024, we have V6.12. of .NET Framework, so it's a full framework working on Linux for desktop applications mainly. We have VB.NET and C-Sharp 7, so he cannot keep up with what Microsoft is doing, right? The open source community turns to the core implementation and now just .NET, so he doesn't have that much contributors. So we are still in C-Sharp 7, but on the .NET framework, we are using C-Sharp 13 now. far back. And there's a lot of good stuff happening from C Sharp 9 onwards. It's insane what you can do. You can just make sure your code is being inlined by the compiler. You can make sure that you stay in processor cache most of the times in some applications that I did before. So it's very powerful to use Microsoft stuff. But he's still working hard on this. He has most of the APIs. He has full support for line queue to objects. It's writing lambdas for collections, like for database, and translating this to database, whatever database you're using. You just write this in C Sharp and it translates to the database commands and also for collections. XML, SQL, Windows Forms, WPF for people from the Microsoft world, this gives us chills. But people are still using it. And they can port applications to Linux. Thanks to Miguel. So now I'm getting to the beginning of the presentation. Because now I gave you guys a context of .NET. You know a lot about .NET now. It's open source. There's no Microsoft involved with it. Even in the governance, they just have grants for developers. And they have, like, developers from their payroll. Just focus it on .NET. But now about myself. So I started reading and writing at four. I started, I learned COBOL and DB2, DBase 2 at five. My mom was a programmer. So she was teaching me how to do COBOL stuff on a 8086, what is Toshiba T1200. So it's like a big laptop, 5, 6 kilos, 25 minutes of battery life, one 20 megabyte hard drive, and one 3.5 inches disk drive. So this was running DOS 3.6. This was my first computer. We got this computer when I was four. And then at five, I was the only one in the house doing stuff for everyone because I knew how to manage it. Then I delved into a lot of programming languages throughout my career. I'm 40, by the way, so this is a long time ago. 35 years ago I started doing this. So I went to C, C++, Pascal, Basic, Visual Basic, Delphi, Perl, Ruby, Python, JS, TS, ActionScripts, Flash. This was the gold back then for websites. Then a lot of stuff in Bash. Java, C Sharp, SQL, you name it. I've been through it all. I've been doing this for 15 years as a professional. And I've been through like 40-something companies in 15 years. So I move a lot. I learn fast. Where they cannot offer me anything else, I move to another company, try to find a challenge. So I went through a lot of things, a lot of different systems through my career. I have experience in embedded systems because back then, the 90s, you're not just doing computers, you're doing like PIC, you're doing 8-bit microprocessors. It was beginning to get cheap, so you write CNC and compile to machine code for those. So I did a lot of professional stuff as well. In São Paulo we have the ATM machines to top up your transit cards. I did that from São Paulo as a whole, Rio de Janeiro, Porto Alegre. It's used on more than 160 cities. And I did from the scratch, from hardware, firmware, software, and everything, recording on the card, the NXP card, my first stuff. I'm a professional programmer for the past 15 years. I have experience in mission-critical applications. Most of my experience is in mission-critical. So the transport system in Brazil, like in Sao Paulo. If I do something wrong and I push to production, there's like hundreds of thousands of angry people at 5 p.m. trying to catch a bus or the subway trying to get home. So I'm very experienced in initial critical stuff. I work at banks in Brazil, a couple of banks, credit card processors, acquirers, subacquirers, transportation cards, like I said. past eight years as a professional. So I left the regular financial system and I went to Bitcoin only. So I worked in a lot of exchanges in Brazil. I did something here and there for exchanges overseas. And then 2024, last year, about June, July, I got my grant from OpenSets to do what I will show you right now. So before this, free open source software, using .NET, there's a bunch. I put some here. If you run a media server at home, you are using .NET without knowing. BTC Pay Server is all written in .NET. The creator of BTC Pay Server is Nicolas Dorier, and he created nBitcoin, which is like a cousin of nLightning, and with both Nicolas, but the n is for .NET. He wrote everything, including Secpy in .NET, managed code. And we have nBitcoin to do everything. I use nBitcoin a lot to talk to Bitcoin, Bitcoin Core. And to do transaction signatures, I use his code. Then we have Radar, Sonar, LiDAR, Prowler. It's used to find torrents and to download music, TV shows, and movies over TorNet. please. And we have Jellyfing as well, which is a media server that you can just use your TV to stream that. So we have a streamer written in .NET as well. And then we have like Umbraco CMS is one of the biggest CMS providers. And it's written in .NET. It's open source. Nope Commerce, Orchard Core, there's a big list. I put some of the biggest ones. And I've skipped this. Who uses .NET in the wild? We have Citigroup, Citibank, JPMorgan Chase, Wells Fargo, Bank of America, HSBC, Standard Chartered, ING, AIG, Aliens, EXA, MetLife, Prudential, Stackoverflow is .NET. So we rely on .NET every day. Every single one of you uses .NET every single day. Dell, GoDaddy, Accenture, Siemens, UPS, and we have everyone that is a gamer. uses .NET because Unity is a game engine that is written in .NET. So why .NET? I guess it's clear by now, right? I want to break the barrier for the big fish. We are not capable of changing the global ecosystem as we as developers. We are not that much doing Bitcoin development. we don't have the buy power to just make something huge that will make Bitcoin mainstream. Those guys, they have. They use .NET. Which CTO from Citibank in their righteous mind will hire a Rust developer in a bank that there's just like thousands of .NET developers to run Bitcoin in-house, to run Lightning in-house. It's not happening anytime soon. They will not run C and C++ because people writing C and C++ are expected to be older than me. So it's not happening. They are not doing it. They do .NET. So I'm trying to break this barrier, offering them a .NET system that they already know. They pay millions of dollars every month. Those companies together pays billions of dollars to Microsoft for support, like top tier support. I worked on the Ministry of Education in Sao Paulo, and we had a memory leak back when .NET was beginning to get open source. And then we were calculating the retirement for the year for all the teachers in Brazil. click in the button nonstop. And then we have to run these calculations whenever they click there. And then it's .NET. And we had a memory leak. We discovered this running a big simulation two years prior to the date. It cannot fail. So we tried to find the memory leak. We were unable to find the memory leak. We called Microsoft. They put an engineer on a call with us. He accessed the production computer, production computer where we were running the simulation. Without seeing the source code, he was able to get the intermediate language and debug this remotely. And then he find out, like debugging the framework code as well, because he has the code in his machine, he can debug that. He found that the memory leak was something on the framework. On the next day, we had a patch, a public patch fixing that. us. And then the next day, it went smoothly. So this is the kind of support I'm talking about. You cannot get this from the ROS community. You cannot get this from the Go community. You cannot get this from Python community. It's inexistent. There's no people that will offer this. Because if they offer this, people will pay top dollar. That's why we have HeadHat. That's why we have OpenSUSE. It's open source. They built it. They sell support. So that's huge like open shoes It's a billion dollar contract with three leather agencies on the United States the the defense uses it like everyone uses FBI NSA They pay for support because if something goes wrong on the operational system they solve it now and Microsoft offers this so they already paying this It's easy if I do something wrong or any of you that wants to contribute to the project If we do something slightly wrong and we cannot fix it Those guys are gonna call Microsoft and they will fix it for us So this is very important for huge companies. I'm breaking a big barrier here What else Well ease of integration with existing services because it's gonna be easy for them to integrate like their app that that is calling dotnet with of lighting implementation. It's easy for them. It has a huge performance. .NET is, you can do crazy stuff. I wrote, alongside three other engineers, I wrote a book, an order book for an exchange in Brazil. We were able in six months to write an order book that was processing 1.6 million transactions per second using .NET. We were debugging stuff. And then we realized the circular array we were using was running on L2 cache, the processor. We wrote a lot of managed code to do this. And it was .NET. At Zebedee, I was writing some stuff there before I leave. And we got 2.6 million transactions per second using .NET. like end-to-end from the user clicking to saving on the database. 2.6 million transactions per second. So it's very performant. We cannot take that out of the table. It's easily scalable because .NET is multi-thread. So you can scale horizontally, you can scale vertically, you can have intelligent balancing tools. If the pressure is too much, goes up can be like very big and it just ingests whatever traffic you have. Then you can go down to smaller machines, put things out. So it's very scalable. It's secure. Everyone is using their support. So all the banks are using it. It's very secure. And it's portable. So they can just decide to move from, I don't know, Linux servers to Windows servers again. I don't know why would they do that. But they can do that. And you don't have to change a single line of code. It just runs. You can just test code, like myself, on a MacBook. It just runs. It's the same experience. I lost my train of thought. Well. Oh, yeah, yeah. So it's very portable because now you don't have to change a single line of code. It just works on every single architecture out there, including embedded systems. So right now, we have .NET Portable. being maintained, you can write .NET code and run on a microprocessor. So it's pretty reliable. So what is Enlightening Endgame? Why am I doing this? So by the end of the year, I will have a full implementation of the Lightning Network. Right now I'm missing two boats. I have the communication layer, the transport layer ready. I have all the messages ready. And it's modular, right? Because I came from an enterprise system. So I'm doing enterprise level code here. So it's very modular. You can just install the boat package. And then using nlighting.boats.boat2 messages. And then you can write whatever you want. And you have the messages there. I just want to import the transport layer. Because I'm doing fishing stuff here and there. and trying to do an interceptor or something, you can do that. You just import both eight. It's a transport layer. And then on top of the base implementation of the spec, I'm doing services that has all the logic for those specifications. So instead of going implementing everything by hand, like I have the transport layer, I have the messages, how do I connect to other Lightning nodes? No, I have a service. the service and .connect and you pass the endpoint and then it will do the noise protocol stuff, it will talk to the other peer, it will go to a peer's list and then you can choose a peer and just send messages. You have a message service, you have the transport service. So it's very scalable and modular. So you can do whatever you want to enlighten code. It's already at 70%. It's unit tested a lot. 75% coverage, branch coverage on this. So it's good to go. It's production ready, I would say. And the good thing is Zebedee already uses it in production. So I launched the package Bolt 11, and Richard, next day, calls me, hey, thank you for that. It's in production at Zebedee. So doing the interceptor stuff, because he was doing some rusty LDK calls. And it's a mess to do those calls in .NET because the names of the functions and the objects and to catch an error, it's insanely huge because of the bindings. So now he has a way of doing this on managed code that he speaks. So Zebedee is using this for six months now. No complaints from Richard. No open ticket yet. I want to implement by the end of the year, this dropping daemon replacement for all the implementations we have out there. So I'm planning to do, I'm expecting help by the middle of the year. I'm expecting help, more hands to code with me. Then by the end of the year, we'll have this replacement, dropping replacements, meaning I will import your configurations, your private keys, and your database. how it runs on landlining. You can choose on landlining right now. You are able to choose from four different databases. So you can use Microsoft SQL, Postgres, MySQL, and Oracle databases. And it's ready. You just create the migrations, and it works on all four databases. And you're welcome to write more implementations to other obscure databases if you want. I want to offer enterprise-level paid support for those companies from the previous slides. So I want to create a company on top of this, just like OpenSUSE did and HeadHead did. So I wrote this. I can give you the best support in the world because I know how it works. So I can train people and we can offer support to those big guns. And then we are breaking that entry barrier for banks and we might have Lightning and Bitcoin for the masses. So that's it. Thank you. This is enlighteningipms.io. This is the documentation portal. And this is the email reaches at IPMS. We have a couple minutes. I want to show you guys what's happening. Can I see it? Oh, thank you. We have the We have the documentation portals. Because in .NET, you can write inline XML comments on your functions and everything. And then you just can create on every release. I have this beautiful specification API. And then you can just go through this and see how to call, how to instantiate the messages, all the objects, what uses it. And it's like document as you code. So this is very powerful as well for the open source community. Well, I guess that's it. Questions? We have like one minute. If you have any questions about it? No? OK, thank you.
