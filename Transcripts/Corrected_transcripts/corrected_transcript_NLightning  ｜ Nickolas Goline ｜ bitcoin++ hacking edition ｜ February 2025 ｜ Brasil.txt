I'm doing this a little differently. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and.NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I'm going to go through this. What is.NET? The architecture, design principles of the.NET architecture, the framework. Architecture, the framework, trying to exercise Microsoft from it so you guys take it easy on me. Then I will talk about myself, show a few projects done in.NET in the wild, and then answer the biggest question of it all: why am I using.NET to re-implement Lightning? And then what is my purpose doing this? So,.NET is a free and open source framework. So.NET is a free and open source framework. It runs on Windows, Linux, and macOS. According to Microsoft, it's just a new platform based on internet standards. So this is pretty important. In July 2000,.NET Framework and C-sharp language were introduced into the world at the PDC, the Professional Developers Conference. And then it was very welcome from the And then it was very welcomed by the community because we need that. Before that, we had Visual Basic, and it was very difficult to work on Internet-first applications. So, back in 2000, in Brazil at least, Internet was just six years old. And then you need something built from Internet. They realized that this was the next big thing. Was the next big thing. And then in December 2001, just a little more than a year and a half after the launch, they published a standard, ECMA standard, 335 and ECMA 334. 335 is for the language itself or C sharp. And sorry, 335 is for the common intermediate language. The common intermediate language and 334 is for the C-sharp language. So it's an open standard. Anyone could just implement the intermediate language part, like the runtime of.NET in any other architecture, operational system. So they created this, expecting people to contribute as well. And then right now we have just the sixth edition. Right now, we have just the sixth edition of ECMA and ISO standards. I will talk more about this later. And the last version is 2012 for the intermediate language stuff. So now I'll talk about architecture because people don't realize how powerful.NET is and how well it runs on every single architecture we have out there, every single operational system. So we have basically like So we have basically like the two big parts on it, and then there are smaller parts inside. We have three languages right now running on.NET. We have C Sharp, we have Visual Basic for legacy stuff, because before C Sharp there there was only Visual Basic. And then here it's a number of things that make it work. So the first part is the CLI that goes here. The CLI that goes here inside. This is the common language infrastructure. So this is a language neutral platform, and you can write code in C. Nowadays we have F sharp as well, is a functional code language that works on.NET framework. So you can write C sharp, F sharp, or VBE for legacy stuff, and it will run on the VB for legacy stuff, and it will run on the same interpreter, the same runtime. J-sharp, as I said, was a transitional language. And then we have the CLR, the common language runtime. So what happens is you write code in C or F sharp, the most user today, and then you compile this language. The compiler will translate whatever you wrote in C sharp or F sharp. Will translate whatever you wrote in C sharp or F sharp, so object-oriented or functional programming. It will translate it to the OS and architecture you chose. So the CLR is the execution engine. It also takes care of like giving away memory, taking care of memory garbage collection, threads. It takes care of it all. And then the memory management, the type. And then the memory management, the type safety, exceptions, garbage collector, security, thread management. It it it's responsible for it all. Uh we have the CIO, the common intermediate language that I spoke about. Uh it's just this thing that the the the the runtime, the interpreter understands, and it's very different from C sharp or F sharp. It's like a assembly. You can read that, it's human readable. Assembly. You can read that. It's human-readable, sorts of, but it's not assembly yet. And then we have the just-in-time compiler. That's the part that takes the intermediate common language and translates it to assembly. Then we have the assemblies that are part of the framework. When you compile your program in C-sharp, it creates this. Your program in C, it creates this portable executable. So, this is not assembly code yet. You cannot just run this on Linux or Windows. This is just this middle format. And then it takes a unique name for that package, for that program. It's comprised of the simple text name, just the name of our package, the version number, the culture, like the language it's written on, and the public key. It's written on, and the public key. You can sign the package, but usually we just use the public key that comes with it. If we're not trying to prove the code or anything, then it takes this, and you have the unique name, the unique natifier of the package. I will show you a little later, but then using this, it knows if it has to compile the code again to machine code or if it has on like a cache. And then we have the class library. And then we have the class library, which is the built-in API for the framework. So you have a couple namespaces. The two most common ones are system.something and Microsoft.something. So those are built-in libraries that you can call to talk like to the OS, to make system calls, function calls to third-party libraries. Third-party libraries, and then you can talk directly to the operational system. The good things about.NET, like the design principles they had in mind before doing this, is the interoperability. So, Windows, who here knows about Windows programming? No one, nice. Yes, just one. So, Windows is like the main. So, Windows is like the mainstream first window like UI operational system we have. And then they needed something to allow the developers to talk directly to the OS. So they created something called COM, the component object model. So you can write COM models in any language, and then this layer in language and then this layer in Windows lets another application use this. A good example of a com model is ActiveX or DirectX that we use to talk directly to the GPU on games. So this was very important since the beginning, since Windows 3.11. Windows 95 made a very heavy usage of this and it's still used in Windows applications. Still use it in Windows applications. And then to talk to this, you have the interop service and the enterprise services. Enterprise services, you talk directly to Windows, Windows Server, and other Windows applications. And interop services, you can talk directly to the Linux or macOS operational system and make system calls. You can call default libraries from the system. Libraries from the system. We have the reverse PINVOK, the platform invoke, to call systems or function calls from the operational system. So you can build base stuff on.NET and have other applications in Linux use it as a library. So in Enlightening, I'm using Libsodium. So this is a good example. I call So, this is a good example. I call libsodium to do the cryptographic stuff, and then it's just a simple call you do. And I could rewrite libsodium in.NET or something better, do something better with my time than trying to rewrite libsodium. And then other people could write C code or C code and call those functions as well from.NET. And language independence is a good principle as well because now we can have. Is a good principle as well because now we can have C sharp, F sharp, and if someone here wants to write a language that runs on top of the standard, the ECMA or ISO standard, you can write your own language as well, your own compiler, and it will run on the.NET framework. Type safety. So.NET is like the .NET is like talking more about the language because when we talk.NET is usually you think about C sharp because the language was introduced at the same time as the framework. So it it likes the same thing. So in C sharp we have CTS and CLR the the common part of the the framework enforcing type safety so it's a strongly typed language. Type safety, so it's a strongly typed language. Everything has to be typed, or else it doesn't work. And then a couple years ago, up to framework,.NET Framework 4.0, it was strictly typed language. And then after OM4.0, they introduced a dynamic language model. They changed it CLR. So C was the first language. So, C-sharp was the first language that adopted it, of course. So, now we have dynamic objects as well. So, this is good if you're trying to use like some JavaScript APIs, because then they don't care about versions or breaking changes, and you're not sure what you're getting from the API. You can just read that object into a dynamic type, and then you can just Type and then you can just call like the object.data and then it tries to find data in that structure. And if there's data, it returns else it's just a null, so you know data is not present there. And this is good for the new kinds of system people are writing nowadays. So it's nice to have a dynamic language, but it's obtained. If you don't want to use dynamics anymore, If you don't want to use dynamics anywhere, just go with the circular type it. Portability, this is good as well. Microsoft implemented the full framework for Windows only. So I will show you a timeline in the next slide. But at some point, it was just.NET, C and VBNET, and J-sharp just for Windows. It was implemented by Microsoft for It was implemented by Microsoft for Microsoft developers and for Microsoft users. So.NET ships in Windows because most of the Windows applications are written in.NET. And then with this open standard, the ECMA standard and the ISO standards, anyone could write the runtime to a specific OS or architecture. And since it's Or architecture, and since it's open, people would be able to run the same code like you write once, the C-sharp code, and it would run on any architecture. It took a while for people to start doing this, but it's portable, it's a portable language. And security, this is a good topic because I will show. A good topic because I will show you later as well, but almost every single bank in the world uses.NET. Almost every single insurance company in the world uses.NET. Almost every single airliner uses.NET on the internal processes. Like Icarus is written.NET. And then it has to be secure. So they have the security, and I will talk a little about the security. And I will talk a little about the security, why they choose this language. So we have its own security mechanism to access memory and take care of the execution of programs. So we have the CAS, the code access security, and the validation and verification of whatever you're trying to run. An example is a method that demands a specific permission from the operation. A specific permission from the operational system. So it will, on execution time, it will walk through all the libraries you're trying to execute. It will walk through this, and then it will find if every single namespace, every single assembly there has that authorization, right? The permission to execute that code. If one of those are missing, To execute that code. If one of those are missing, it throws an exception, a security exception, and the code will not execute. So you can create very robust secure applications. One little caveat of the security is you have, like I said, you have an intermediate language that is human-readable. So.NET was launched on Visual Studio, and on Visual Studio, you have a disassembler. And on Visual Studio you have a disassembler. And since it's an intermediate language, very readable, you can very easily get a portable executable, like the compiled stuff, and you can get back almost the original source code from this library or an application. And you can see every single method, the tabulation, everything. It almost rewrites it completely. Everything. It almost rewrites it completely. So companies were like, well, this is not good because if I have some proprietary code and I'm publishing it, anyone can read my code, anyone can copy me. So from the second version of Visual Studio with.NET, it ships with Microsoft Ofuscator. And then there's a plethora of obfuscators out there. We have VMware. Out there. We have VMware obfuscators, we have JetBrains obfuscators, like a lot. We have more than 25 commercials available and free ones like the Microsoft one that ships with Visual Studio. So you can obfuscate your code as well. So memory management. Like I said,.NET is a managed framework. So you don't take care of memory. So, you don't take care of memory. The framework takes care of memory for you. So, a lot of you work in C, C, Rust, Go. In Rust, like you have to instantiate the object, you call for memory, you use that point of memory, and then you use the pointer here and there, and then you are responsible for clearing that pointer or lending that pointer to another function and all of that. To another function and all of that. In C, C, you have to really take care of everything. There's no landing, there's no anything. The compiler doesn't know what's happening. So you are responsible. In.NET Framework, you don't care. You just new object, and it takes memory from the pool of memory from the runner that is taking care of your application. And then whenever you're not using that pointer anymore, the garbage collector goes there. That pointer anymore, the garbage collector goes there and just frees the memory and compacts the memory, and that's it. So CLR handles all of this memory operations. The instantiations are allocated from the manage pool. And then, as long as there is a reference, it's considered being used. And then, as long as there is no reference on the tree, the memory tree. The tree, the memory tree, it can be freed. It's considered garbage. And the garbage collector, which is a big selling point of.NET over Java, it runs periodically, but we don't know when it runs. So it's a non-deterministic garbage collector. It depends on how much memory your application is using and the memory pressure from the operational system. If the system starts telling the The system starts telling the runtime, like I need memory, then it runs the garbage collector, but we don't know when. And then it's a mark and sweep garbage collector. And I will tell you a little more about this. So it pulses the app, your application is paused whenever the garbage collector needs to run. But it runs in a way that is very performant. So it pulses the application, goes. So it pauses the application, goes through the three routes we have, like system objects, static objects, and user objects. And then it walks through the tree and then finds through disassembly sometimes objects inside of objects and all the pointers they have. If something is in memory and it's not on this tree, it marks as garbage. When it finishes this walkthrough, When it finishes this walkthrough, it just marks that memory as free, and then it compacts the memory, the memory pool. So it moves around all the objects in the memory to have a contiguous memory, right? So it's easier, it's faster when you want to instantiate a new object. It goes to the end of the pool, so it's very fast to give you memory. But then the question is, But then the question is, this runs whenever it wants. I don't know when. And it pauses my application and goes through the whole tree and compacts the memory. This is low. And actually, no, because it uses a generational stuff. So the first time it runs, it runs through the tree. And then it marks objects that have pointers still being used. It marks as gen 1 and what's not. It marks as gen 1, and what's not being used, it's freed. And then the next run, it will not go through generation 1 because it's supposed to be long-lived. So it just runs through like newly created objects. After this, it will run a couple more times, and then whoever survives generation one, then it's a long-lived object. So it goes to generation two. And generation two garbage collecting happens. Garbage collecting happens less often. So it's not running through your whole memory, your object tree, every time. It just goes through generation zero a lot, generation one a little, and generation two almost never. Performance. So the CIL code compilation is performance. Code compilation is performed on the first run. So, whenever you build a new program, you change it, something, you're going to run it. Remember, you have this intermediate language. It's not built for, it's not compiled to your architecture and operational system. So, the first run will compile the code to machine code, and then this compiled machine code executable goes to a cache,.NET cache. A cache,.NET cache. And then, whenever you try to run this another time, it gets that unique ID, like the version, the name, the culture, pub key. If it has on the cache, it just runs whatever it has from the cache. So the first run is lower, like not considerably slower. I'm used to having startup times on the first time, like two or three seconds. Second time is just two or three seconds, second time is just milliseconds because it just goes to the cache and and runs the application. We have a r ahead of time compilation for this specific purpose because if I have an application that I uh like a core application of my system and this has to run the first time very fast because I don't have time. Like it's a Lambda or something written dot net. It has to run fast on the first call. Retain.NET, it has to run fast on the first call. So you can do ahead of time compilation because you know the architecture, you know the operational system. You just manually compile that to assembly code, to machine code, and then you ship that assembly code. And then on the first run, it's already on cache, right? You don't have to compile to that architecture anymore. It's already there. As I said, like the GC can introduce and I said the GC can introduce unanticipated lag delays on the execution, but you can try to bypass it and you can try to run the GC manually as well. On enlightening, I have a lot of unmanaged code. And whenever you're doing unmanaged code, you're responsible for the memory from that point on. So we have some calls that you So, we have some calls that you can tell GC that you have memory pressure and that GC should run faster than it would otherwise. And you can remove pressure, like I'm not using that much memory, I'm not about to run a big process. Let the GC run less often. And then you have a way of forcing GC collect. I've done this before. We had like on a I had done this before. We had like on a bank, we were processing those consolidation files. So it's just clear text, hundreds of megabytes, almost one gigabyte file, like all the transactions from the day between two banks, and they are trying to consolidate all of that shit. Then I would call GC collect before doing that processing, because I forced the GC to the garbage collector. Because I forced the GC to the the garbage collector to go through generation zero, one and two and absolutely clean the memory. So I have more memory to work with on the pool, more contiguous memory, which is more important. So now the Microsoft apostasy. Let's exorcise the Microsoft demon out of.NET. How it went, the open sourcing of.NET. And this is a part where everyone gets it wrong. Part where everyone gets it wrong. When I say that I'm doing.NET implementation of Lightning, people just go bananas. Like, what are you doing? Why.NET? Are you crazy? And even further, we already have four implementations. Why a fifth one? And in a language that is not open source. So here it is. July 2000, C-sharp introduction. And then January 2001,.gnu. .gnu. It's a free open source Linux implementation of the ECMA standards. So they re-implemented from scratch the intermediate language compiler to architecture specific and the runtime that deals with threads, memory, and whatever else. So following the standard, the specification, they were implemented. Following the standard, the specification, they were implementing it.New, unfortunately, went through some pushback from the open source community because back in 2001, it was very new. They were afraid of moving, getting too close to the beehive and getting sued by Microsoft. Because it was like no one knows what Microsoft will do. It's an open standard, but what if I try to do stuff that But what if I try to do stuff that is not the CLI or the C-sharp language? What if I'm doing something that is proprietary work from Microsoft? They can sue us. So this project doesn't went far. But then in July 2001, Mono was another free open source implementation for Linux. This launched it at O'Reilly conference. The guy behind it, I will talk a little more. Conference, the guy behind it, I will talk a little more about him. The guy behind it started working in like July 2000, but then he realized it was an Herculean task to rebuild everything from scratch for Linux. And I'm talking like Windows stuff from the framework because they were trying to port.NET applications to run natively on Linux without using Wine or anything like this. So he was rewriting everything. So he was rewriting every single bit. And then he decided it was not an easy task, so I will call for help. So it was open sourced in July 2001. Then July 2004, just three years after going open source, model 1.0 was released, the first major version. I use that a lot because I started doing.NET stuff in 2001. So I use that a lot to port my applications to Linux. I use that a lot to port my applications to Linux, to run on Linux. But it was a mess, right? It was a guy not from Microsoft trying to implement stuff from scratch. In 2012, we got a setback from the community. I remember some Reddit drama back then because someone at Microsoft, like a VP, tried to grab control of the repository, tried to change. Control of the repository, try to change how commits were made, how mergs were accepted, and how the release were made on.NET. And then we have a pushback from the community. They ended up letting people go or moving to another area apart from.NET Framework. And then they changed the licensing terms and the patent for.NET Framework to be .NET framework to be anyone does whatever they want. We cannot sue you, even if you infringe on patents, because now it's just a holding patent. It's not a patent anymore. You can do whatever you want. You can use Microsoft code whatever you want, and you can just create your own implementation. So, this was a piloting point where Microsoft just stepped away from the.NET-like governance. .NET like governance, and now it's ours. Then November 2014, just two years after that,.NET Core was introduced. So we have.NET Framework, it's proprietary, it's Windows only, and we have.NET Core. Now it runs on Linux, macOS, and Windows natively. And all the APIs, the lower-level APIs were written. The lower level APIs were written by Microsoft employees. And now the full source was open sourced. So now it's our code for real this time. And then here is where it's a little sad because Mono and the Mono developer were not invited to come along. Mono was a thing, and.NET Core was another. And then they were like clashing against each other because people were using Mono with a lot of Other because people were using mono with a lot of bugs, and you know, it was harsh. And then there's Microsoft doing what the guy was doing, and then everyone just moved it to.NET Core. Then.NET Core 1.0, 2016, 2017, the second version, 19, the last version. We have 18, 2.4, 2.6, 2.7, and then 3.0. 6, 3.7, and then 3.0 in July 2019, December we have 3.1. This was the last.NET Core implementation. After this, they skipped.NET 4. So.NET Framework was on the version 4, and they didn't want people to have one or the other erroneously because both were 0.4. So they skipped 2019. Both were 0.4. So they skip it. 2020, we have.NET 5. They got rid of the proprietary stuff from the framework. They ported 100% of the APIs to the open source code. And now the open source code contains Windows original code for us to use. So 2020, another big landmark for us. We have stable releases every November. The event numbers are long-term support, three years. The even numbers are long-term support, three years. The odd numbers are one and a half year support. Right now, November last year, we have.NET 9, which is not long-term support. So I'm sticking to.NET 8. And this year I will move my application to.NET 10. C-sharp launches a new major as well alongside.NET new versions. So C Sharp, we are on C12.NET 9. C sharp 12, C sharp.NET 9 is C sharp 13, and this year we will have.NET 10, C sharp 14. They have a minimization of breaking chains mindset, so it works for at least nine years, whatever you have. So we have code, like not crazy code, like vanilla code written in C sharp, that C sharp for.NET 1.0, 2.0 framework. For.NET 1.0, 2.0 framework that still runs on Linux on.NET 9 because there's not that much breaking changes. So you can run legacy applications to this day. So Mono. Let's talk about Mono. It was created by Miguel de Casa. A lot of people know this guy because he created GNOME. And he is the founder of Ximian and Xamarin. Is the founder of Ximian and Xamarin. For people that delve it into Android iOS apps in.NET, we had Xamarin because he wrote the framework from scratch for iOS and Android. So you wrote.NET applications running on Android and iOS. He did it from scratch for Linux desktop apps at first. He open sourced it in July. At first, he opened sources in July, as I said. The parent Ximian was acquired by Novell in 2003 and then he was acquired with the company. He worked on this company. It was still like Ximian, but it was Novell. He sold every single patent and license that he has to Novell. It was part of the deal. to Novell. It was part of the deal. And then we had a problem in Novell because they just went bankrupt. So they started letting go of a lot of people, including Miguel de Casa. And then it was a a hard time for us using this, using mono for Linux because we don't know what's happening because the license know what's happening because the license is Novell's licenses. And then Miguel launches Xamarin and then there's this gray area. What we will do? Can we keep working on what we were working? Is it the same work we were doing at Novell? We cannot do this anymore. Novell just stopped supporting the mono framework. And then in 2011, Novell granted a perpetual licensing. Novell granted a perpetual licensing to Xamarin over Mono, MonoTouch, and Mono Android. MonoTouch was for iOS. And then we got back to having.NET applications safely on Android and iOS. The v4 incorporated in 2012, v4 incorporated original Microsoft code that was open sourced after that pushback from the community. After that pushback from the community in 2012, because then Microsoft let everyone use their code. So they just grab a lot of code from Microsoft, and now Mono runs very smooth. And as of June 2024, we have v6.12. It has the core API of.net framework, so it's a full framework working on Linux for desktop applications. Working on Linux for desktop applications mainly. We have VBNet and C7, so he cannot keep up with what Microsoft is doing, right? The open source community turns to the core implementation and now just.NET. So he doesn't have that much contributors. So we are still in C7, but on the.NET framework, we are using C13 now. So he's far back. And there is a lot of Far back, and there is a lot of good stuff happening from C 9 onwards. It's insane what you can do. You can just make sure your code is being inlined by the compiler. You can make sure that you stay in processor cache most of the times in some applications that I did before. So it's very powerful to use Microsoft stuff. But he's still working hard on this. And he's still working hard on this. And he has most of the APIs. He has full support for line queue to objects. It's writing lambdas for collections, like for database, and translating this to database, whatever database you're using. You just write this in C sharp and translates to the database commands and also for collections. XML, SQL, Windows Forms, WPF. Forms, WPF for people from the Microsoft world, this gives us chills, but people are still using it. And they can import applications to Linux, thanks to Miguel. So now I'm getting to the beginning of the presentation because now I gave you guys a context of.NET. You know a lot about.NET now. It's open source. There is no Microsoft involved. Even in the governance, they just It even in the governance, they just have grants for developers, and they have like developers from their payroll just folks that are.NET. But now about myself. So I started reading and writing at four. I started, I learned COBOL and DB2, DBase2 at five. My mom was a programmer, so she was teaching me how to do COBOL stuff on an 80. teaching me how to do COBOL stuff on a 8086 what is Toshiba T twelve hundred so it's like a big laptop like five six kilos twenty five minutes of battery life one twenty megabyte hard drive and one three point five inches disk drive so this was and running DOS six point uh three point six this was my first computer we got this computer when I was four My first computer. We got this computer when I was four. And then at five, I was the only one in the house doing stuff for everyone because I knew how to manage it. Then I delved into a lot of programming languages throughout my career. I'm 40, by the way, so this is a long time ago. 35 years ago, I started doing this. So I went to C, C, Pascal, Basic, Visual Basic, Delft, Delphi, Pro. DeFi, Perl, Ruby, Python, JS, TS, ActionScripts for Flash. This was the goal back then for websites. Then a lot of stuff in Bash, Java, C, SQL, you name it. I've been through it all. I've been doing this for 15 years as a professional. And I've been through like 40-something companies in 15 years. Like 40-something companies in 15 years. So I move a lot, I learn fast. When they cannot offer me anything else, I move to another company, try to find a challenge. So I went through a lot of things, a lot of different systems through my career. I have experience in embedded systems because back then in the 90s, you're not just doing computers, you're doing like PIC, you're doing 8-bit microprocessors. You're doing 8-bit microprocessors. It was beginning to get cheap, so you write CNC and compile to machine code for those. So I did a lot of professional stuff as well. In São Paulo, we have the ATM machines to top up your transit cards. I did that from São Paulo as a whole, Hugo Nero, Portalegri. It's used on more than 160 cities. And I did from the scratch, from hardware, firmware, software, and everything. Firmware, software, and everything, recording on the card, and an XP card, my fair stuff. I'm a professional programmer for the past 15 years. I have experience in mission-critical applications. Most of my experience is in mission-critical. So, the transport system in Brazil, like in Sao Paulo. If I do something wrong and I push code to production, there's a like To production, there's like hundreds of thousands of angry people at 5 p.m. 5 p.m. trying to catch a bus or the subway trying to get home. So I'm very experiencing initial critical stuff. I work at banks in Brazil, COPOF banks, credit card processors, acquires, subacquires, transportation cards, like I said. And I've been working with Bitcoin for the And I've been working with Bitcoin for the past eight years as a professional. So I left the regular financial system and I went to Bitcoin only. So I worked in a lot of exchanges in Brazil. I did something here and there for exchanges overseas. And then 2024, last year, about June, July, I got my grant from OpenSats to do what I will show you right now. So before this, free open source software using.NET, there's a bunch. I put some here. If you run a media server at home, you are using.NET without knowing. BTC Pay Server is all written.NET. The creator of BTC Pay Server is Nicola Dorier. And he created and Bitcoin, which is like a cousin. And Bitcoin, which is like a cousin of N Lightning, and with both Nicholas. But the end is for.NET, right? So he wrote everything, including SECP in.NET managed code. And we have NBitcoin to do everything. I use NBitcoin a lot to talk to Bitcoin, Bitcoin Core, and to do like transaction signatures. I use his code. Then we have radar, sonar, lidar, prowler. Radar, sonar, LiDAR, Prawler. It's used to find torrents and to download music, TV shows, and movies over Tor network, please. And we have Jellyfing as well, which is a media server that you can just use your TV to stream that. So we have a streamer written in.NET as well. And then we have like Umbraco CMS, which is one of We have like Umbraco CMS, which is one of the biggest CMS providers, and it's written in.NET, it's open source. Nope Commerce, Orchard Core, there's a big list. I put some of the biggest ones. And I skipped this: who uses.NET in the wild? We have Citigroup, Citibank, JP Morgan Chase, Wells Fargo, Bank of America, HSBC, Standard Charter, ING, AIG, Aliens, Exa, MetLife. Aliens, Exa, MetLife, Prudential, Stack Overflows.NET. So we rely on.NET every day. Every single one of you uses.NET every single day. Dell, GoDaddy, Accentury, Siemens, UPS, and we have everyone that is a gamer uses.NET because Unity is a game engine that is written in.NET. So why.NET? I guess it's clear by now, right? Now, right, I want to break the barrier for the big fish. We are not capable of changing the global ecosystem as we as developers. We are not that much doing Bitcoin development and we don't have the buypower to just make something huge that will make Bitcoin. make something huge that will make Bitcoin mainstream. Those guys, they have. They use.NET. Which CTO from Citibank in her in his their righteous mind will hire a Rust developer in a bank that there's just like thousands of.NET developers to run Bitcoin in-house, to run Lightning in-house? It's not happening. To run Lightning in-house, it's not happening anytime soon. They will not run C and C because people writing C and C are expected to be like older than me. So it's not happening. They are not doing it. They do.NET. So I'm trying to break this barrier, offering them a.NET system that they already know. They pay millions of dollars every month. Those companies together pay billions of dollars. Those companies together pay billions of dollars to Microsoft for support, like top-tier support. I work on the Ministry of Education in Sao Paulo, and we had a memory leak back when.NET was beginning to get open source, and then we were calculating the retirement for the year for all the teachers in Brazil. So you can imagine retired. Brazil. So you can imagine retired teachers clicking the button non-stop and then we have to run these calculations whenever they click there and then it's.NET and we had a memory leak. We discovered this running a big simulation two years prior to the date. It cannot fail. So we tried to find the memory leak. We were unable to find the memory leak. We called Microsoft. They put an engineer on a car with us. They put an engineer on a car with us. He accessed the production computer, like the pre-production computer where we were running the simulation. Without seeing the source code, he was able to get the intermediate language and debug this remotely. And then he find out, like debugging the framework code as well, because he has the code in his machine. He can debug that. He found that the memory leak was something on the framework. That the memory leak was something on the framework. On the next day, we had a patch, a public patch, fixing that. They installed it for us, and then the next day, it went smoothly. So, this is the kind of support I'm talking about. You cannot get this from the Rust community, you cannot get this from the Go community, you cannot get this from the Python community. It's inexistent. There's no people that will offer this because if they offer this, people will. We will offer this because if they offer this, people will pay top dollar. That's why we have Hat Hat, that's why we have OpenSUSE. It's open source, they build it, they sell support. So that's huge. Like OpenSUSE, it's a billion-dollar contract with three leather agencies on the United States. The defense uses it. Like everyone uses it. FBI, NSA, they pay for support because if something goes wrong, Say they pay for support because if something goes wrong on the operational system, they solve it now. And Microsoft offers this. So they're already paying this. It's easy. If I do something wrong, or any of you that want to contribute to the project, if we do something slightly wrong and we cannot fix it, those guys are going to call Microsoft and they will fix it for us. So this is very important for huge companies. I'm breaking a big barrier here. Big barrier here. What else? Well, ease of integration with existing services, because it's going to be easy for them to integrate their app that is calling.NET with a Lightning implementation. It's easy for them. It has a huge performance.NET is you can do crazy stuff. crazy stuff. I wrote alongside three other engineers, I wrote a book, an order book for an exchange in Brazil. We were able in six months to write another book that was processing 1.6 million transactions per second using.NET. We were debugging stuff and then we realized it the circular Realize it, the circular array we were using was running on L2 cache, the processor. We wrote a lot of unmanaged code to do this, and it was.NET. At Jebudee, I was writing some stuff there before I leave, and we got to 2.6 million transactions per second using.NET. Like end-to-end, from the user clicking to saving on the database. 2.6 million. To saving on the database, 2.6 million transactions per second. So it's very performant. We cannot take that out of the table. It's easily scalable because.NET is multi-thread. So you can scale horizontally, you can scale vertically, you can have like intelligent balancing tools. If the pressure is too much, the next machine that goes up can be very big and it Goes up can be like very big, and it just ingests whatever traffic you have. Then you can go down to smaller machines, put things out. So it's very scalable. It's secure. Everyone is using it, their support. So all the banks are using it. It's very secure. And it's portable. So they can just decide to move from, I don't know, Linux servers to Windows servers again. I don't know why they do that, but they can do that. Would they do that? But they can do that. And you don't have to change a single line of code. It just runs. You can just test code like myself on a MacBook. It just runs. It's the same experience. I lost my train of thought. Well. Oh, yeah, yeah. So it's very portable because now you can you don't have to si change a single line of code. It just works on every single architecture out there, including embedded systems. Architecture out there, including embedded systems. So, right now we have.NET portable being maintained. You can write.NET code and run on a microprocessor. So it's very reliable. So, what is Lightning Endgame? Why am I doing this? So, by the end of year, I will have a full implementation of the Lightning network. Right now, I'm missing two boats. two boats. I have the communication layer, the transport layer ready. I have all the messages ready. And it's modular, right? Because I came from an enterprise system. So I'm doing enterprise level code here. So it's very modular. You can just install the the boat package and then using enlightening.boats.boat2 messages. Two messages. And then you can write whatever you want, and you have the messages there. I just want to import the transport layer because I'm doing like phishing stuff here and there and trying to do an interceptor or something. You can do that. You just import both eight, it's a transport layer. And then on top of the base implementation of the spec, I'm doing services that has all the logic for those specifications. Those specifications. So instead of going implementing everything by hand, like I have the transport layer, I have the messages. How do I connect to other lightning nodes? No, I have a service. So you just instantiate the service and.connect, and you pass the endpoint. And then it will do the noise protocol stuff, it will talk to the other peer, it will go to a peers list, and then you can choose a peer and just send messages. And then you can choose a peer and just send messages. You have a message service, you have the transport service. So it's very scalable and modular. So you can do whatever you want to enlighten in code. It's already at 70%. It's unit tested a lot. I have 75% coverage, branch coverage on this. So it's good to go. It's production ready, I would say. And the good thing is, And the good thing is, Zebedee already uses it in production. So I launched the package Bolt 11, and Richard next day calls me, hey, thank you for that. It's in production at Zebriti. So doing the interceptor stuff, because he was like doing some rusty LDK calls, and it's a mess to do those calls in.NET because the names of the fundamental Because the names of the functions and the objects, and to catch an error, it's insanely huge because of the bindings. So now he has a way of doing this on managed code that he speaks. So Zabeli is using this for six months now. No complaints from Richard, no open ticket yet. I want to implement by the end of the year this dropping demon replacement for all the Replacement for all the implementations we have out there. So I'm planning to do, I'm expecting help by the middle of the year. I'm expecting help, more hands to code with me. Then by the end of the year, we will have this replacement, dropping replacements, meaning I will import your configurations, your private keys, and your database, and now it runs on end lighting. You can choose on end lighting. It runs online lighting. You can choose online lighting right now. You are able to choose from four different databases. So you can use Microsoft SQL, Postgres, MySQL, and Oracle databases. And it's ready. You just create the migrations and it works on all four databases. And you're welcome to write more implementations to other obscure databases if you want. In the near future, In the near future, I want to offer enterprise-level paid support for those companies from the previous slide. So, I want to create a company on top of this, just like OpenSUSE did and Head Hat did. So, I wrote this. I can give you the best support in the world because I know how it works. So, I can train people, and we can offer support to those big guns. And then, we are breaking that entry barrier for banks, and we might have. Breaking that entry barrier for banks, and we might have Lightning and Bitcoin for the masses. So that's it. Thank you. This is enlightening IPMS.io. This is the documentation portal. And this is the email reaches at IPMS. We have a couple minutes. I want to show you guys what's happening. Can I see it there? Oh, thank you. So thank you. We have the documentation portals because in.NET you can write inline XML comments on your functions and everything. And then you just can create on every release, I have this beautiful specification API, and then you can just go through this and see Through this and see how to call, how to instantiate the messages, the audio objects, what uses it. And it's like document as you code. So, this is very powerful as well for the open source community. Well, I guess that's it. Questions? We have like one minute. If you have any questions about it? About it? No? Okay, thank you.


I'm doing this a little differently. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other language is not supported by a huge company or anything like this. So let's dive in. So I will talk about something here, then I will talk about myself and my background, and then I will talk about the project. So I will give you guys a little introduction on why this is the biggest question. So you can see it here. So you can see it here. How about using an enterprise language for a change, right? I guess this is missing on the Bitcoin space. It's an enterprise language. We have just Java and .NET. Any other
