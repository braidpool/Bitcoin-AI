Hi, I'm Elias. I'm or Tinal on Twitter or online anywhere. I'm an engineer with Spiral working on the Lightning DevKit. And this talk will be a bit more technical than the talks I heard in this stage before today. Although I think there are a lot of connections that can be drawn from the other talks to this. Yeah, as the title states, this is on Bolt 12: what it is, why we 12, what it is, why we want it, and how to integrate it with Aldikinode. Alright, where are we today? So, today we have Vault 11 invoices. Everybody is familiar with them, they're ubiquitous, used everywhere you use Lightning today. And they're the original payment protocol essentially invoices. They're great, they are tried and true, and they work so far. Great, they are tried and true, and they worked so far pretty well in the most part. But everybody is kind of aware of the flaws that old 11 invoices have. In particular, they have this interactivity requirement, basically. So, if you want to pay a friend, you always have to ask them first: hey, can you send me an invoice? Because they're not reusable. And this is kind of annoying to always ask somebody. And this is kind of annoying to always ask somebody, hey, please send me an invoice, I want to send you some money. And even more so, of course, they're kind of large. If you can see this here, it's probably hard to read. But the data that goes into Vault 11 invoice, the encoding is rather large, which is fine if you just send it as a text message or whatever. But if you want to encode them in a QR code, which is the usual way we do lightning. them in a QR code, which is the usual way we do Lightning transactions these days, it's kind of annoying that they are so large because you might want to add additional data into that same QR code and the more data you put into your QR code, I'm not sure if you're aware of that, the harder it gets to scan. It gets more dense and that means that all the smartphones for example have an issue scanning them if the camera isn't that great. But even worse than these issues basically which are mainly Even worse than these issues, basically, which are mainly UX issues. Bolt 11 has poor privacy generally because it leaks the pay puck key. You always, if you send an invoice to somebody, you say, Hey, this is my node. You leak your identity, basically. So we don't have what's called recipient anonymity in the Bolt 11 world. Of course, there are some ways to mitigate some of it. Somehow, you can also. There are some ways to mitigate some of it. Somehow you can always run on Tor or whatever, but in general, this is not the greatest thing to have. We want to have recipient anonymity. L and URL lightning addresses mitigate some of the UX issues just discussed. So they allow to retrieve individual invoices from a web server. So instead of asking your friend every time, Hey, can you give me a new invoice? You ask a web server, Hey, can I get a new invoice? Ask a web server, hey, can I get a new invoice? And this improves CUX. The issue with that is it requires running a web server, which is kind of annoying because that is another tech stack you have to work with. It introduces additional complexity. And on top of that, there are additional privacy and security risks that just come with running or with. Risks that just come with running or with that increased attack surface essentially of running a web server. So it improved things considerably, but it's still not quite there, what we really want. Of course, that's where Bolt 12 comes in, Bolt 12 to the rescue. Granted, it has been a long time coming, so it's a really slow job to the rescue, essentially. I think I just looked at The rescue, essentially. I think I just looked it up these days. In just a few days, I think August 31st will be like four years' anniversary that Rusty opened the spec PR for the offers for Vault 12 on the Lightning spec repo. So it has been some time that protocol devs have been working on this and discussing this and so on. But the good thing is, the good news is it's here. It's actually working and it has. It's here. It's actually working and it fixes basically all the aforementioned drawbacks of Vold11. We have reusable smaller offers, they keep on static. You can generate them. You can put them on a website or whatever. They don't change. And then people can send you money. Even more so, it guarantees receiver or recipient anonymity. You don't leak your pubkey anymore. You don't leak your PUBKI anymore, and you have no additional dependencies to your tech stack with all the drawbacks we just discussed because it's now an actual base protocol of the Lightning or baseback of the Lightning protocol and is already implemented in your Lightning Node, hopefully. So, to focus on the privacy aspect, real quick, and here it gets a bit technical, but I don't. Aspect real quick, and here it gets a bit technical, but I don't want to get into too much detail. How does Bolt 12 ensure the private part? How do we get around leaking the pub key? Well, BOT-12 uses something that's called blinded paths. So, this whole thing is a depiction of a blinded path. And you can see here is this opaque thing that is, you cannot look into it basically, this whole box. So, instead of the recipient node, So instead of the recipient node actually putting its pub key in there, the only thing that the sender sees is the introduction point. And everything in here is encrypted actually multiple times via on your encryption, meaning that the only thing that's leaked is a introduction node that is chosen by the recipient itself. And so now when that is included in the offer here, and that is the offer that is just sent Here. And that is the offer that is just sent via QR code, like out of bounds, like we do currently with Bolt 11 invoices to Alice, the sender. And you see, it's a blinded path in there. So, what Alice now does, if she wants to pay this offer, is to send an invoice request using that blinded path to Bob via the introduction node, of course, not to Bob directly. And then Bob responds with a BOLD 12. And then Bob responds with a BOLT12 invoice. Yes, on the protocol level there is something like a BOLD 12 invoice, but you likely will never see it using it because it's really a protocol detail, it's really a message on the protocol level. The only thing you should really deal with is offers and what we call refunds, basically invoice requests if you want to refund somebody. Anyways, there is BOLT12 invoices that will be sent back via similar That will be sent back via similar reply path construction basically. So, Bob also still doesn't know who Alice is. And then, finally, we can send the actual payment. So, you see, it's a kind of involved protocol, lots of cryptography going on, and all of this is communicated over onion messages on the protocol level. And these onion messages are then routed. And these on-year messages are then routed. Here is another depiction. Basically, here you have your route in the network, and this would be your introduction point. And here's Bob. So hopefully, this will be routed in a network via onion messages. Slight caveat here: currently, as not everybody currently in the network is supporting BOL 12, or rather, onion message forwarding, more often than not, we currently, when we use BOL 12, we connect to We currently, when we use Bolt 12, we connect to the introduction point directly and send the on message from there. But in the future, and I'll be coming back to that, we hopefully see full routed onion messages. So, how does adoption look like? Bolt 11, I said, is ubiquitous. And where are we with Bolt 12 currently? Well, Phoenix deployed it. You can use it today in the wallet. It works. It, you can use it today in the wallet. It works. LDK, we support it in LDK, LDK node. It's ready to go. CLN, although, while they, I think, currently catching up to the latest spec, but it's really just pending a release, they support it, of course. And LND is committed to add support in the near future. And meantime, you can run a project LNDK, which is basically a needle. Which is basically a neat little project, a separate daemon on top of LD that provides on-year message forwarding and also bolt 12 sent to you if you run an LND node. So I can just encourage to do that. Cool. So, apart from that, why do you start actually adopting it? Sounds a bit complicated to get started, especially if you're not super technical or if you're not too. Or if you're not too familiar with the Lightning protocol details. So, where do we start? The answer is a thing we call LDK Node. LDK Node is a Lightning Node library based on LDK and BDK, so it comes with an associated on-chain wallet ready out of the box. And the focus of LDK Node is really to provide a simplified experience to provide a simplified experience to write self-custodial lightning nodes. Thank you. So it provides a library so you can write self-custodial lightning notes. And we think self-custody is important. Self custody is important. I agree with the talk before that it's hard currently in many aspects. Self-custody and Lightning can be hard, but we are on the other hand working hard towards making it simpler for users and LDK Note hopefully helps you to do that so you can just include it and integrate it in your app and basically we take care of all these protocol details for you. We take care of all these protocol details for you. It has a modular architecture, so it comes with customizable chain data, gossip data, entropy, and liquidity source backend. So we integrate with the LSP spec, for example, to also solve stuff like onboarding of initial users. We integrate LSPS2, which the JIT channel spec is called. So, where you would, for example, to be able to create an invoice, and then when the invoice To create an invoice, and then when the invoice is paid, the LSP you connect to automatically opens a channel to you, hopefully, even a ZeroConf channel, which makes onboarding really seamless. So, if you're aware of the Phoenix onboarding experience, where you don't have to care if you have an initial channel open or not, basically you get the same thing with this Justin Times back. And then we provide language windings to you. Provide language bindings to you so that while it is written in Rust LDK node, you can write your programs in Kotlin Swift, Python, Flutter, React Native, Go, C, in all these languages, and they should basically have the same simplified API ready to go so you can integrate self-custodial Lightning Nose, for example, in your mobile application. So, I want to run through. So, I want to run through a real quick example just to showcase that it's really straightforward to use it. Although I'm not expecting, I'm not entirely sure how the crowd here is, how technical people are, so I try to keep this short. Just to get set up with a node, essentially, you would create a builder object, and on this builder, you can configure all. Builder object, and on this builder you can configure all kinds of things. That is basically the modular architecture I just described. You can plug in your own explorer backend or whatever, configure, I want to run this on testnet or mainnet or whatever, reg test. And then you call just builder.build and you get a node object. And this is your Lightning Node. You're basically done. You just set up the Lightning Node. And you call start on it, and then it starts up, and it has things with the And then it starts up and it has its syncs with the Explorer server, it updates fees and so on. So basically, in these five lines of code, you already set up a Lightning node. And yeah, that is more or less ready to go. You can then get a funding address, for example, to fund the node and then open a channel, which we see in the next step. Or, as I just mentioned, you can call one method to get a just-in-time invoice to You get a just-in-time invoice that is then payable. And if you connect to an LSP, you would also configure that on the builder. The LSP would open the channel to you. Similar, as I just mentioned, you would also just, it's essentially one method call to open a channel to another node. You just say, okay, I want to connect to this pub key at this address, and then you would open a channel and you get an event back when. You get an event back when the channel is opened. And coming back to BOL 12, this is basically the same goes for integrating BOL 12. So we really tried to streamlight the API here to make it really easy to integrate BOL 12 payments. Once you have an open channel, you have liquidity, either via the LSP or you did manually open the channel, you can just call node. Open a channel, you can just call node volt12payment.send for any given offer, and there goes your volt 12 payment. And that in the background does take care of all that complexity I mentioned in the beginning. Similarly, of course, you can also receive to volt 12 by just creating an offer and then giving that out, and that would be your static offer that people can send payments to many times. Payments too many times. And we also, as I mentioned before, support refunds, for example. That is essentially, you can think of them as invoice requests without an offer that kind of switches around the flow I showed before. Don't want to get into details too much here. So, just to wrap this up, essentially, this example: this is a fully functional Rust program setting up. Functional Rust program, setting up a Lightning Node, starting the Lightning Node, getting a funding address where you then can fund, opening a channel, and sending a BOLT 12 payment. So, in this, what is it? Maybe if you cut out the white space, it's actually 15 lines of code or something, you integrated BOLT-12 payments. Cool. So, it's not that complicated to get started. that complicated to get started. And the future that was the future for the last four years is now here. Now that the future is here, what what's next? For one, human readable names will be upcoming, which is the current BIP proposal by Matt Corello and T-Bust also. And there's the idea we can include these static offers now into Static offers now into the DNS domain name system as static entries, and we get something that is very similar to an email address format where you don't have to remember or you don't have to scan the QR code, you have actually a human-readable name for somebody. So, in many use cases, scanning a QR code makes more sense. But if you just want to ask a friend, hey, we just had dinner or whatever, I want to pay you back what. We just had dinner or whatever. I want to pay you back. What's your human-readable name? That is much easier than sending around QR codes or offer encodings. That will be great. Then people are also working on, actually, a colleague of mine is working on the async payment proposal, which will finally enable async receive. That has to do with an even more complicated. That has to do with an even more complicated protocol based on onion messages, a lot more messages to be exchanged and a lot more tricky details where which onion message will be held at which LSP site basically to be to enable async payments. But that is coming and is actively worked on. And finally, coming back to the note of forwarding or routed Forwarding or routed Pol 12 payments, these will be coming in the future. As currently, around 6% of the forwarding nodes in the network have onion message forwarding enabled. CLN currently, it's an experimental feature, you have to enable it. So, I encourage you: if you run a CLN node, please enable on-year message forwarding. And if you run LND, as mentioned before, please run LND. Mentioned before, please run LNDK. You get both twelve send for free and you also help the network to get this number higher so we can have eventually routed both twelve payments for the full network. I mentioned as I said, direct connecting the introduction point is fine for now, but eventually we want to reach fully routed payments in the network. Cool. So far for that inter creation talk. For that intercreation talk, thanks so much for the attention. If you want to want to get further resources, please visit lightningdevkit.org. We have also a very active Discord community where we answer all your where we try to give great user support. So ask anything there also. You can reach me via underscore Tino on X, I guess, and/or alias at spiral.xyz. And or Elias at spiral.xyc, or just ask now, please. Cool. Thank you. Hey. For the Bolt 12 refund, I'm assuming where the refund being pushed from is the guy who's going to send the fees, right? Like, where do the fees come from? If it's going to be rerouted backwards, I'm guessing that they're not going to just. I'm not, I'm guessing that they're not gonna just give away the fees, right? No, for the refund, it's actually, I mean, refund is a bit at the same time the right notion, but it's also confusing because it's not actually rewarding the actual payment, right? It's a new payment, we just call it refund because it inverts the direction. So, in the bold, in the offer case, you basically scan an offer, you send an invoice request, basically say, Hey, I want to give you money, please send. Basically, say, hey, I want to give you money, please send me an invoice. And with refund, you basically do it the other way around. The original recipient, if we keep it in the refund use case, would send back directly an invoice request saying, Hey, here's an invoice request. If you send me an invoice, I can give you money, basically. That just switches, that leaves out the first offer request, basically, or the invoice request. request basically, or the invoice request stuff, yeah. Could you give a bit more details on the BIP353 with the the human readable name and the integration with DNS? How will it technically work with the integration on DNS? Well, it's just a TXT record basically, where you add that to your domain you control. To your domain you control. You would secure that via the NSSEC, so that nobody or that is basically assigned. And then there are basically two different options how you could go. You could either do a wildcard thing that might make more sense for a big custodian that has thousands and thousands of users, where you can say basically thousands of user where you can say basically yeah you would basically s pay to one to one specific uh offer and then uh give additional data to let the custodian know, okay, this is for this user, that is one, then you would have just one entry, or you can have individual entries per user and have individual offers essentially per user. So every user would have an individual entry. So, every user would have an individual entry. And the format of those entries, would they look like an email address or is it like alias.spiral.xyz? Is it free? I think it could be free text. Yeah, I think the Bitcoin design community discussed that a lot. How should we basically format these human-readable names? Because from a technical level, you can do, of course, everything. And as far as I'm aware, the last point of discussion. The last point of discussion ended up being that it should look like an email address, so you can easily copy and paste it, but it is prefixed with a Bitcoin sign, or you can either write the Bitcoin sign, or it should always in the UI be prefixed with a Bitcoin sign, so it is clearly distinguishable from an email address. Because if you use the email address format like Lightning address, you can have conflicts with actual. Can have conflicts with actual email addresses, and that is kind of annoying in some parts. Maybe in setups where you already have email addresses and you want to run Lightning addresses on top, but they might not always match or something like that. So, yeah, to get around this, the idea is to have the address clearly distinguishable to show: okay, this is not actual email address, let's say. I don't know what Intimail or Wi-Fi. If you go to 12. If you go to 12.cache, I don't know if you can show it here quickly, but some of the designers have been experimenting with what that actually looks like in practice, and you can generate your own bit 353 compliant name. So, yeah, check out 12.cache. I wanted to ask how reliable is the Bolt 12 compared to Bolt 11. I can imagine if some To Bolt 11, I can imagine if some nodes in the past get offline or if there are liquidity problems, then the invoice stops working. Or how does it work? So, from the payment reliability, it's the same. It's just a bit more messaging complexity. So, the payment step is exactly the same as with Bolt 11. It's really just before you would just immediately. Really, just before you would just immediately send the payment after getting the invoice, and now you have basically this one and a half round trips or so in the beginning to negotiate until you get the invoice, essentially. So it's just a bit more complexity on negotiating, and there things can currently fail, but you can essentially just retry. Yeah. Okay, thank you. Yeah. Okay, thank you. So, but the point, maybe just to add to that, the thing, like, the good thing is that what makes Lightning payments sometimes fail is that mostly there's not enough liquidity on the end. And on-in messages don't have this limit, so, or are not encumbered by any kind of liquidity, so they're not expected to be unreliable in the same sense as payments are. So, we're not getting. In the same sense as payments are. So, we're not getting a lot more unreliable with that. So, if there's a basically, if you have a TCP connection with a node, you should be able to send. And if you don't have one, you can't send a payment over that link anyways. Okay, thanks. The async payments in the future, what does that refer to? Because it's already async, meaning like. It's already async, meaning like you make the offer today, you get paid tomorrow. Yeah. The async payment part is really that currently both parties have to be online at the same point in time to be actually to send and receive the payment. Because you send out the HTLC and then have to claim it back, and you have to not like for every part, you have to keep online to actually be able to claim it again. And async payments is essentially a model. And async payments is essentially a model, without getting too much details here, where likely both sides would have an LSP. And you could think, so if you want to do it really trivially, you would have like, or a real simple way to do that would be basically to have hodl payments, essentially, and you would just wait until the receiver comes back online. But that's horrible for network liquidity, to just block out. But that's horrible for network liquidity, to just block out liquidity. So the idea with async payments is both sides would have an LSP and you would hold the liquidity only on the like on the sender side basically. So the liquidity is only locked between the sending node and their LSP. And then you would have an on-in message protocol that would negotiate and basically notify the LSPs, hey, the receiver now came online, please forward this payment now. Now came online, please forward this payment now. You're able to receive it. And actually, the other way around, also. So yeah. It's a bit more tricky to get everything right, but I think we're making good progress there. Thank you. And just to clarify, this would really solve the major lightning drawback of having to be online to receive payments. So finally, can solve that. Can solve that. Cool. Great, then thank you again.


Hi, I'm Elias. I'm or Tinal on Twitter or online anywhere. I'm an engineer with Spiral working on the Lightning DevKit. And this talk will be a bit more technical than the talks I heard in this stage before today. Although I think there are a lot of connections that can be drawn from the other talks to this. Yeah, as the title states, this is on Bolt 12: what it is, why we 12, what it is, why we want it, and how to integrate it with Aldikinode. Alright, where are we today? So, today we have Vault 11 invoices. Everybody is familiar with them, they're ubiquitous, used everywhere you use Lightning today. And they're the original payment protocol, essentially, invoices. They are great, they are tried and true, and they work so far. Great, they are tried and true, and they worked so far pretty well in the most part. But everybody is kind of aware of the flaws that old 11 invoices have. In particular, they have this interactivity requirement, basically. So, if you want to pay a friend, you always have to ask them first: hey, can you send me an invoice? Because they're not reusable. And this is kind of annoying to always ask somebody. And this is kind of annoying to always ask somebody, hey, please send me an invoice, I want to send you some money. And even more so, of course, they're kind of large. If you can see this here, it's probably hard to read. But the data that goes into Vault 11 invoice, the encoding is rather large, which is fine if you just send it as a text message or whatever. But if you want to encode them in a QR code, which is the usual way we do Lightning transactions these days, it's kind of annoying that they are so large because you might want to add additional data into that same QR code, and the more data you put into your QR code, I'm not sure if you're aware of that, the harder it gets to scan. It gets more dense, and that means that all the smartphones, for example, have an issue scanning them if the camera isn't that great. But even worse than these issues, basically, which are mainly UX issues. Bolt 11 has poor privacy, generally, because it leaks the pay puck key. You always, if you send an invoice to somebody, you say, Hey, this is my node. You leak your identity, basically. So we don't have what's called recipient anonymity in the Bolt 11 world. Of course, there are some ways to mitigate some of it. Somehow, you can also. There are some ways to mitigate some of it. Somehow you can always run on Tor or whatever, but in general, this is not the greatest thing to have. We want to have recipient anonymity. L and URL lightning addresses mitigate some of the UX issues just discussed. So they allow you to retrieve individual invoices from a web server. So instead of asking your friend every time, hey, can you give me a new invoice? You ask a web server, hey, can I get a new invoice? Ask a web server, hey, can I get a new invoice? And this improves UX. The issue with that is it requires running a web server, which is kind of annoying because that is another tech stack you have to work with. It introduces additional complexity. And on top of that, there are additional privacy and security risks that just come with running or with that increased attack surface, essentially, of running a web server. So it improved things considerably, but it's still not quite there, what we really want. Of course, that's where Bolt 12 comes in, Bolt 12 to the rescue. Granted, it has been a long time coming, so it's a really slow job to the rescue, essentially. I think I just looked it up these days. In just a few days, I think August 31st will be like four years' anniversary that Rusty opened the spec PR for the offers for Vault 12 on the Lightning spec repo. So it has been some time that protocol devs have been working on this and discussing this and so on. But the good thing is, the good news is it's here. It's actually working, and it fixes basically all the aforementioned drawbacks of Vault 11. We have reusable, smaller offers, they keep on static. You can generate them. You can put them on a website or whatever. They don't change. And then people can send you money. Even more so, it guarantees recipient anonymity. You don't leak your pubkey anymore. You don't leak your PUBKI anymore, and you have no additional dependencies to your tech stack with all the drawbacks we just discussed, because it's now an actual base protocol of the Lightning protocol, and is already implemented in your Lightning Node, hopefully
